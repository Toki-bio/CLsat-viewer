<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="0" />
<title>CLsat Locus Detail Viewer – Per-window Bitscores</title>

<!-- D3.js - load from CDN -->
<script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>

<style>
  :root{
    --bg:#0b0e14;
    --panel:#111827;
    --panel2:#0f172a;
    --text:#e5e7eb;
    --muted:#9ca3af;
    --grid:#1f2937;
    --okFill: rgba(34,197,94,0.35);
    --compFill: rgba(245,158,11,0.40);
    --contraFill: rgba(239,68,68,0.45);
    --conflictFill: rgba(168,85,247,0.40);
    --strokeContra:#ef4444;
    --strokeComp:#f59e0b;
    --strokeOk:#22c55e;
  }
  html,body{height:100%; margin:0; background:var(--bg); color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;}
  .wrap{display:grid; grid-template-columns: 340px 1fr; gap:12px; height:100%; padding:12px; box-sizing:border-box;}
  .wrap.collapsed{grid-template-columns: 0px 1fr; gap:0;}
  .sidebar{
    background:linear-gradient(180deg,var(--panel),var(--panel2));
    border:1px solid #1f2937;
    border-radius:14px;
    padding:12px;
    overflow:auto;
    transition: width 0.2s, padding 0.2s, opacity 0.15s, border 0.2s;
  }
  .wrap.collapsed .sidebar{padding:0; border:none; overflow:hidden; opacity:0; pointer-events:none;}
  .collapseBtn{position:fixed; top:6px; left:6px; z-index:100; background:#1e293b; color:#9ca3af; border:1px solid #334155; border-radius:8px; width:28px; height:28px; cursor:pointer; font-size:16px; display:flex; align-items:center; justify-content:center;}
  .collapseBtn:hover{background:#334155; color:#fff;}
  .main{
    display:flex;
    flex-direction:column;
    gap:12px;
    min-width:0;
  }
  .chartPanel{
    background:linear-gradient(180deg,var(--panel),var(--panel2));
    border:1px solid #1f2937;
    border-radius:14px;
    padding:12px;
    display:flex;
    flex-direction:column;
  }
  .topChart{flex:0 0 auto; height:200px;}
  .detailChart{flex:1; min-height:300px;}
  h1{font-size:16px; margin:0 0 8px 0;}
  h2{font-size:12px; margin:10px 0 5px 0; color:var(--muted); font-weight:600; letter-spacing:.02em;}
  .row{display:flex; gap:6px; align-items:center; margin:4px 0;}
  label{font-size:11px; color:var(--muted); width:80px;}
  select,input,button{
    background:#0b1220;
    color:var(--text);
    border:1px solid #243044;
    border-radius:6px;
    padding:5px 8px;
    font-size:11px;
    outline:none;
  }
  select,input{flex:1;}
  button{cursor:pointer; border-color:#2b3a55; white-space:nowrap;}
  button:hover{border-color:#3b82f6;}
  .pill{display:inline-block; font-size:11px; padding:4px 8px; border:1px solid #243044; border-radius:999px; color:var(--muted);}
  .status{
    white-space:pre-wrap;
    background:#0b1220;
    border:1px solid #243044;
    border-radius:12px;
    padding:10px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    font-size:11px;
    color:#d1d5db;
    line-height:1.35;
    margin-top:10px;
    max-height:180px;
    overflow:auto;
  }
  .small{font-size:11px; color:var(--muted); line-height:1.35;}
  .legend{display:flex; flex-wrap:wrap; gap:10px; margin-top:8px;}
  .legendItem{display:flex; align-items:center; gap:6px; font-size:11px; color:var(--muted);}
  .swatch{width:14px; height:14px; border-radius:4px; border:1px solid #243044;}
  .chartTop{display:flex; gap:10px; align-items:center; justify-content:space-between; margin-bottom:6px;}
  .chartInfo{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
  .kpi{font-size:11px; color:var(--muted);}
  .kpi b{color:var(--text); font-weight:600;}
  .hint{font-size:10px; color:var(--muted); margin-top:4px;}
  .ok{color:#34d399;}
  .err{color:#fb7185;}
  .chartBox{border:1px solid #243044; border-radius:14px; overflow:hidden; background:#070b12; flex:1; min-height:0;}
  .panelTitle{font-size:13px; font-weight:600; margin-bottom:6px; display:flex; align-items:center; gap:8px;}
  .bedBox{background:#0b1220; border:1px solid #243044; border-radius:10px; padding:10px; margin-top:6px; display:flex; align-items:center; gap:8px;}
  .bedCoord{font-family: ui-monospace, monospace; font-size:12px; color:#60a5fa; flex:1; user-select:all;}
  .copyBtn{padding:6px 12px; font-size:11px; cursor:pointer; background:#1e3a5f; border:1px solid #2563eb; border-radius:6px; color:#60a5fa;}
  .copyBtn:hover{background:#2563eb; color:#fff;}
  .copyBtn:active{transform:scale(0.95);}
  .fastaBtn{padding:6px 12px; font-size:11px; cursor:pointer; background:#1e4d3f; border:1px solid #10b981; border-radius:6px; color:#34d399;}
  .fastaBtn:hover{background:#10b981; color:#fff;}
  .fastaBtn:active{transform:scale(0.95);}
  .fastaBtn:disabled{opacity:0.5; cursor:not-allowed;}
  .fastaResult{background:#0b1220; border:1px solid #243044; border-radius:10px; padding:10px; margin-top:6px; display:none;}
  .fastaResult.show{display:block;}
  .fastaHeader{font-size:11px; color:var(--muted); margin-bottom:6px; display:flex; justify-content:space-between; align-items:center;}
  .fastaSeq{font-family: ui-monospace, monospace; font-size:11px; color:#d1d5db; white-space:pre-wrap; word-break:break-all; max-height:200px; overflow-y:auto; user-select:all;}
  .monomerBtn{padding:6px 12px; font-size:11px; cursor:pointer; background:#4d1e3f; border:1px solid #a855f7; border-radius:6px; color:#c084fc;}
  .monomerBtn:hover{background:#a855f7; color:#fff;}
  .monomerBtn:active{transform:scale(0.95);}
  .monomerBtn:disabled{opacity:0.5; cursor:not-allowed;}
  .monomerResult{background:#0b1220; border:1px solid #243044; border-radius:10px; padding:10px; margin-top:6px; display:none;}
  .monomerResult.show{display:block;}
  .monomerHeader{font-size:11px; color:var(--muted); margin-bottom:6px; display:flex; justify-content:space-between; align-items:center;}
  .monomerList{font-family: ui-monospace, monospace; font-size:10px; color:#d1d5db; max-height:150px; overflow-y:auto; margin-bottom:8px; resize:vertical; min-height:40px;}
  .monomerItem{padding:4px 6px; margin:2px 0; background:#070b12; border-left:3px solid #a855f7; border-radius:4px;}
  .alignmentBox{font-family: ui-monospace, monospace; font-size:9px; color:#d1d5db; white-space:pre; overflow-x:auto; max-height:300px; overflow-y:auto; background:#070b12; padding:8px; border-radius:6px; line-height:1.3; resize:vertical; min-height:40px;}
  .monomerMap-label{font-family: ui-monospace, monospace; font-size:9px; fill:#9ca3af;}
  .monomerMap-arrow{stroke-width:1; cursor:pointer; opacity:0.9;}
  .monomerMap-arrow:hover, .monomerMap-arrow.hl{opacity:1; filter:brightness(1.4) drop-shadow(0 0 3px rgba(255,255,255,0.4));}
  .monomerMap-arrow.dim{opacity:0.3;}
  .msaBlock{overflow-x:auto; font-family:'Courier New',ui-monospace,monospace; font-size:10px; line-height:1.15; background:#070b12; padding:4px 6px; border-radius:6px; margin-bottom:6px; white-space:nowrap; resize:vertical; min-height:30px; max-height:80vh; overflow-y:auto;}
  .msaBlock .msaRow{white-space:nowrap; height:1.15em; cursor:default;}
  .msaBlock .msaRow.hl{background:#1a1a3a;}
  .msaBlock .msaRow.dim{opacity:0.3;}
  .msaBlock .msaName{color:#9ca3af; display:inline-block; width:26ch; text-align:left; flex-shrink:0; overflow:hidden; text-overflow:ellipsis;}
  .msaBlock .msaBase{display:inline-block; width:1ch; text-align:center;}
  .msaBlock .msaMatch{background:#0c2a0c; color:#34d399;}
  .msaBlock .msaMismatch{font-weight:bold;}
  .msaBlock .msaGap{color:#444;}
  .msaBlock .msaCons{color:#9ca3af;}
  .msaBlock .msaIdent{color:#666; font-size:9px; margin-left:4px;}
</style>
</head>

<body>
<button class="collapseBtn" id="collapseBtn" title="Toggle sidebar">«</button>
<div class="wrap">
  <div class="sidebar">
    <h1>CLsat Locus Detail Viewer <span id="versionTag" style="font-size:9px; color:#f59e0b; font-weight:normal;"></span></h1>
    <div class="small">
      Click a locus in the scaffold overview to see per-window bitscores below.
    </div>

    <h2>Navigation</h2>
    <div class="row">
      <label>Species</label>
      <select id="speciesSel"></select>
    </div>
    <div class="row">
      <label>Scaffold</label>
      <select id="scaffoldSel"></select>
    </div>
    <div class="row">
      <label>Jump</label>
      <select id="jumpSel"></select>
    </div>
    <div class="row">
      <label>Find locus</label>
      <input id="findInput" placeholder="e.g. L144" />
    </div>
    <div class="row">
      <label></label>
      <button id="findBtn">Go</button>
      <button id="resetBtn">Reset zoom</button>
    </div>

    <h2>Filters</h2>
    <div class="row">
      <label>Show</label>
      <select id="flagFilter">
        <option value="ALL">ALL</option>
        <option value="SEED_ONLY">SEED_ONLY</option>
        <option value="SEED_WITH_COMPETITOR">SEED_WITH_COMPETITOR</option>
        <option value="SEED_CONTRADICTION">SEED_CONTRADICTION</option>
      </select>
    </div>

    <h2>Monomer Analysis</h2>
    <div class="row">
      <label>Min Identity</label>
      <select id="minIdentity">
        <option value="0.95">95%</option>
        <option value="0.85">85%</option>
        <option value="0.75" selected>75%</option>
        <option value="0.65">65%</option>
        <option value="0.55">55%</option>
      </select>
    </div>

    <h2>CLsat colors</h2>
    <div class="legend">
      <div class="legendItem"><span class="swatch" style="background:rgba(96,165,250,0.9)"></span> CLsat1</div>
      <div class="legendItem"><span class="swatch" style="background:rgba(52,211,153,0.9)"></span> CLsat2</div>
      <div class="legendItem"><span class="swatch" style="background:rgba(244,114,182,0.9)"></span> CLsat3</div>
      <div class="legendItem"><span class="swatch" style="background:rgba(251,191,36,0.9)"></span> CLsat4</div>
    </div>

    <div id="status" class="status">Loading…</div>
    <div class="hint">Wheel to zoom, drag to pan. Click locus to see per-window detail.</div>
  </div>

  <div class="main">
    <div class="chartPanel topChart">
      <div class="chartTop">
        <div class="panelTitle">Scaffold Overview <span class="pill" id="fileOk"></span></div>
        <div class="chartInfo">
          <div class="kpi">Loci: <b id="kpiLoci">0</b></div>
          <div class="kpi">Visible: <b id="kpiVis">0</b></div>
        </div>
      </div>
      <div class="chartBox" id="chartOverview"></div>
    </div>

    <div class="chartPanel detailChart">
      <div class="chartTop">
        <div class="panelTitle">Per-window Bitscores: <span id="detailTitle" style="color:#60a5fa;">Click a locus above</span></div>
        <div class="chartInfo">
          <div class="kpi">Windows: <b id="kpiWindows">0</b></div>
          <div class="kpi">Max bits: <b id="kpiMaxBits">0</b></div>
        </div>
      </div>
      <div class="chartBox" id="chartDetail"></div>
      <div class="bedBox">
        <div class="bedCoord" id="bedCoord">Scaffold coordinates in BED format will appear here</div>
        <button class="copyBtn" id="copyBedBtn">Copy BED</button>
        <button class="fastaBtn" id="fastaBtn">Get FASTA</button>
        <button class="monomerBtn" id="monomerBtn">Analyze Monomers</button>
        <button class="copyBtn" id="serverToggleBtn" style="margin-left:8px;">Start Server</button>
        <span id="serverStatus" style="font-size:10px; color:#9ca3af; margin-left:8px;"></span>
      </div>
      <div class="fastaResult" id="fastaResult">
        <div class="fastaHeader">
          <span id="fastaStatus">Fetching from NCBI...</span>
          <button class="copyBtn" id="copyFastaBtn" style="display:none;">Copy FASTA</button>
        </div>
        <div class="fastaSeq" id="fastaSeq"></div>
      </div>
      <div class="monomerResult" id="monomerResult">
        <div class="monomerHeader">
          <span id="monomerStatus">Analyzing monomers...</span>
          <button class="copyBtn" id="copyAlignmentBtn" style="display:none;">Copy Alignment</button>
        </div>
        <div class="monomerList" id="monomerList"></div>
        <div id="monomerMap" style="margin:8px 0; overflow-x:auto;"></div>
        <div style="margin:4px 0;"><button class="copyBtn" id="copyFastaAlnBtn" style="display:none;">Copy All FASTA</button></div>
        <div id="monomerMSA" style="margin:8px 0;"></div>
        <div class="alignmentBox" id="alignmentBox"></div>
      </div>
      <div class="hint" id="detailHint">Bars show bitscore at each scan window position. Colors = CLsat consensus.</div>
    </div>
  </div>
</div>

<script>
/* ============================================================================
   FILES (relative to this HTML file)
============================================================================ */
const FILE_MASTER_MERGED = "MASTER.merged.bed";
const FILE_ASSIGN        = "MASTER.final_assignment.clean.tsv";
const FILE_BITS_MATRIX   = "MASTER.locus_bits.tsv";

// Per-window bitscore files (one per CLsat)
const FILE_BITS_CLSAT = {
  CLsat1: "MASTER_CLsat1.bits.tsv",
  CLsat2: "MASTER_CLsat2.bits.tsv",
  CLsat3: "MASTER_CLsat3.bits.tsv",
  CLsat4: "MASTER_CLsat4.bits.tsv",
};

/* ============================================================================
   CONSENSUS SEQUENCES (embedded so no server is needed)
============================================================================ */
const CONSENSUS_SEQS = {
  CLsat1: "AAAGAAGCTAGTTNGGATGTATTTGGCTTTTCTAACGTTCAGTTTGGCTTACTTGCGTGATTTTGCATTAACAGCTCAAATACAGCTAACTTTGGAAATGAACACGATGGAAACTTGTTGGTGTGTTTTCTATGCATTTCGACCTG",
  CLsat2: "AAAGAAGCTCATTGGGATGTAGTTGTGTTTCTAAGCTTCATTTTAGCTTATTTGCGTGATTTCGCTTTTAAGGCTCAAATACAGCTATCTTTTGAAAGCAACACGTTAGAAACTTCTTGGTGTGTTTTTCATGCATTTGGACCCA",
  CLsat3: "AAAGAAGCTCGTTCGGATGTCTTTCTGTTTTCTAAGCTTCATTTGAGCTTCTTTGCGTCAATTTGCACTCCAGACTCAAAAACGGCTCTCTTTTGAAAGGAACACCAAAGAAGCTTGTTCGTGTGTTTCCCATGCATTTCCAGCCC",
  CLsat4: "AAAGAAGCTCGTTTGGATGTATTTGCGTGACTTTGCATTCACAACTCAAAAACACATATCTTTTGAAATGAAGGTGATGGAAGCTTGTTCGTGTGTTTTCTATGCATTTCGAGCCT",
};

// Cluster consensus sequences (cl1–cl9) and their CLsat subfamily mapping
const CLUSTER_SEQS = {
  cl3: "AAAGAAGCTAGTTGGGATGTATTTGGCTTTTCTAACGTTCAGTTTGGCTTACTTGCGTGATTTTGCATTAACAGCTCAAATACAGCTAACTTTGGAAATGAACACGATGGAAACTTGTTGGTGTGTTTTCTATGCATTTCGACCTG",
  cl6: "AAAGAAGCATGTTAGGATGTACTTGGCTTTCCTAACGTTCAGTTTGGCTTATTTGCGTGATTTGGCATTAACAGCTCAAATACACCTAACTTTGCAAATGAACACGATAGAAACTTGTTGGTGTGTTTTCTATGCATTTCGACCTG",
  cl4: "AAAGAAGCTAGTTCGGACGTACTTGGCTTTTGTAACGTTCAATTTGGCTCATTTGCGCGATTTTGCATTAACAGCTCAAGTACACCTAACTTTGCAAATGAACACGATGGGAACTTGCTGGTGTGTTTTCTATGCATTTCGACCTG",
  cl7: "AAAGAAGCTATTTCGGATGTACTTGGCTTGTGTAACGTTCAGTTTGGCTCATTTGCGCGATTTTGCATTAACAGCTCAAGTACACCTAACTTGGGAGAGAAACACGATGGACGCTTGCTGGTGTGTTTTCTATGCATTTCGACCTG",
  cl8: "AAAGAAGCTAGTTTGGGTGTTCAGTTTGGCTTACTTGCGTGATTTTGCATTAACAGCTCAAATACAGCTAACTTTGGAAATGAACACGATGGAAACTTGTTGGTGTGTTTTCTATGCATTTCGACCTG",
  cl2: "AAAGAAGCTCATTGGGATGTAGTTGTGTTTCTAAGCTTCATTTTAGCTTATTTGCGTGATTTCGCTTTTAAGGCTCAAATACAGCTATCTTTTGAAAGCAACACGTTAGAAACTTCTTGGTGTGTTTTTCATGCATTTGGACCCA",
  cl5: "AAAGAAGCTCGTTCGGATGTCTTTCTGTTTTCTAAGCTTCATTTGAGCTTCTTTGCGTCAATTTGCACTCCAGACTCAAAAACGGCTCTCTTTTGAAAGGAACACCAAAGAAGCTTGTTCGTGTGTTTCCCATGCATTTCCAGCCC",
  cl9: "AAAGAAGCTCGTTCGGATGTATTTGTGTTTTCTAACCTTCATTTTAACTTATTTGCGTGACTTTGCATTCACAACTCAAAAACACCTATCTTTTGAAATAAACATGATAGAAGCTTGTTCGTCTGTTTTCCATGCATTTCGACCCC",
  cl1: "AAAGAAGCTCGTTTGGATGTATTTGCGTGACTTTGCATTCACAACTCAAAAACACATATCTTTTGAAATGAAGGTGATGGAAGCTTGTTCGTGTGTTTTCTATGCATTTCGAGCCT",
};
const CLUSTER_TO_CLSAT = {
  cl3: 'CLsat1', cl6: 'CLsat1', cl4: 'CLsat1', cl7: 'CLsat1', cl8: 'CLsat1',
  cl2: 'CLsat2',
  cl5: 'CLsat3', cl9: 'CLsat3',
  cl1: 'CLsat4',
};
// Reverse: CLsat type → list of cluster names
const CLSAT_TO_CLUSTERS = {};
for (const [cl, ct] of Object.entries(CLUSTER_TO_CLSAT)) {
  if (!CLSAT_TO_CLUSTERS[ct]) CLSAT_TO_CLUSTERS[ct] = [];
  CLSAT_TO_CLUSTERS[ct].push(cl);
}

const VIEWER_VERSION = "v2.8-cluster-labels-20260219";
console.log("%c[CLsat Viewer] " + VIEWER_VERSION + " loaded", "color:#f59e0b; font-weight:bold; font-size:14px;");
// Show version in UI header
document.addEventListener('DOMContentLoaded', () => {
  const vTag = document.getElementById('versionTag');
  if (vTag) vTag.textContent = VIEWER_VERSION;
});

/* ============================================================================
   CLIENT-SIDE SMITH-WATERMAN MONOMER FINDER (replaces monomer_server.py)
   Mimics the searsat16 pipeline:
     1. Smith-Waterman local alignment of consensus vs locus
     2. Merge overlapping hits (like bedtools merge -s -d -1)
     3. Filter by min homology% and min length (Slf * consensus length)
     4. Split into arrays at >100bp gaps
     5. Require >=4 monomers per array
============================================================================ */

/** Smith-Waterman local alignment with affine-gap scoring.
 *  Scoring matches searsat16: match=+2, mismatch=-2, gap_open=-3, gap_extend=-1
 *  Returns all non-overlapping hits above a score threshold.
 */
function smithWaterman(query, subject, opts = {}) {
  // Scoring mirrors ssearch36 -r +2/-2 -g -3 (FASTA36 defaults: -f -16 gap open, -g -3 gap extend)
  // In affine model first gap residue costs gapOpen+gapExt, matching ssearch36's -f = -16
  const match    = opts.match    ??  2;
  const mismatch = opts.mismatch ?? -2;
  const gapOpen  = opts.gapOpen  ?? -13;  // -13 + (-3) = -16 = ssearch36 default DNA gap open
  const gapExt   = opts.gapExt   ??  -3;  // ssearch36 -g -3
  const qLen = query.length;
  const sLen = subject.length;

  // Affine gap: H = substitution matrix, E = gap in subject, F = gap in query
  const H = new Float32Array((qLen + 1) * (sLen + 1));
  const E = new Float32Array((qLen + 1) * (sLen + 1));
  const F = new Float32Array((qLen + 1) * (sLen + 1));
  const traceH = new Uint8Array((qLen + 1) * (sLen + 1)); // 0=stop,1=diag,2=up(F),3=left(E)

  const w = sLen + 1;
  const qU = query.toUpperCase();
  const sU = subject.toUpperCase();

  // Collect all cells above threshold for multi-hit extraction
  let allMax = 0;

  for (let i = 1; i <= qLen; i++) {
    for (let j = 1; j <= sLen; j++) {
      const idx = i * w + j;
      const sc = (qU[i-1] === sU[j-1] && qU[i-1] !== 'N') ? match : mismatch;
      E[idx] = Math.max(H[(i) * w + (j-1)] + gapOpen + gapExt, E[(i) * w + (j-1)] + gapExt);
      F[idx] = Math.max(H[(i-1) * w + (j)] + gapOpen + gapExt, F[(i-1) * w + (j)] + gapExt);
      const diag = H[(i-1) * w + (j-1)] + sc;
      const best = Math.max(0, diag, E[idx], F[idx]);
      H[idx] = best;
      if (best === 0) traceH[idx] = 0;
      else if (best === diag) traceH[idx] = 1;
      else if (best === F[idx]) traceH[idx] = 2;
      else traceH[idx] = 3;
      if (best > allMax) allMax = best;
    }
  }

  // Threshold: require score >= 35% of perfect single-monomer match
  const threshold = Math.max(qLen * match * 0.35, 20);

  // Extract multiple non-overlapping hits by repeated traceback
  const used = new Uint8Array((qLen + 1) * (sLen + 1));
  const hits = [];

  for (let pass = 0; pass < 5000; pass++) {
    // Find max cell not yet used
    let maxVal = 0, maxI = 0, maxJ = 0;
    for (let i = 1; i <= qLen; i++) {
      for (let j = 1; j <= sLen; j++) {
        const idx = i * w + j;
        if (!used[idx] && H[idx] > maxVal) {
          maxVal = H[idx]; maxI = i; maxJ = j;
        }
      }
    }
    if (maxVal < threshold) break;

    // Traceback
    let i = maxI, j = maxJ;
    let alignLen = 0, matches = 0;
    const endJ = j; // subject end (1-based)
    while (i > 0 && j > 0 && H[i * w + j] > 0) {
      const idx = i * w + j;
      used[idx] = 1;
      const t = traceH[idx];
      if (t === 1) { // diagonal
        if (qU[i-1] === sU[j-1] && qU[i-1] !== 'N') matches++;
        alignLen++;
        i--; j--;
      } else if (t === 2) { // up (gap in subject)
        alignLen++;
        i--;
      } else if (t === 3) { // left (gap in query)
        alignLen++;
        j--;
      } else break;
    }
    const startJ = j; // subject start (0-based)
    const identity = alignLen > 0 ? matches / alignLen : 0;
    hits.push({
      start: startJ,
      end: endJ - 1,  // 0-based inclusive
      score: maxVal,
      identity: identity,
      length: endJ - startJ,
      alignLen: alignLen,
      matches: matches,
    });
    // Mark all cells in the hit region to avoid re-picking overlapping hits
    for (let ii = 1; ii <= qLen; ii++) {
      for (let jj = startJ + 1; jj <= endJ; jj++) {
        used[ii * w + jj] = 1;
      }
    }
  }

  hits.sort((a, b) => a.start - b.start);
  return hits;
}

/** Reverse complement a DNA string */
function revComp(seq) {
  const comp = {A:'T', T:'A', G:'C', C:'G', N:'N', a:'t', t:'a', g:'c', c:'g', n:'n'};
  return seq.split('').reverse().map(c => comp[c] || c).join('');
}

/**
 * Split any hit wider than maxHitLen into individual monomers using iterative
 * pairwise alignment to its own consensus. Operates on a flat array of hits.
 * @param {Array} hits - array of hit objects with start, end, strand, clsat, etc.
 * @param {string} fallbackConsensus - fallback consensus DNA string (used if hit has no clsat)
 * @param {string} rawSeq - the full forward-orientation sequence
 * @param {number} maxHitLen - maximum allowed hit span (end-start+1)
 * @returns {Array} hits with wide ones decomposed
 */
function splitWideHits(hits, fallbackConsensus, rawSeq, maxHitLen) {
  if (!hits.length) return hits;
  const out = [];
  for (const m of hits) {
    const span = m.end - m.start + 1;
    if (span <= maxHitLen) {
      out.push(m);
      continue;
    }
    // Use per-hit consensus if available
    const consensus = (m.clsat && CONSENSUS_SEQS[m.clsat]) || fallbackConsensus;
    const consLen = consensus.length;
    const consU = consensus.toUpperCase();
    // Decompose: extract subject region, revcomp if minus, iteratively align
    const fwdSlice = rawSeq.substring(m.start, m.end + 1);
    const readSeq = m.strand === '-' ? revComp(fwdSlice) : fwdSlice;
    let off = 0;
    let splitOk = false;
    for (let si = 0; si < 20 && off < readSeq.length; si++) {
      const rem = readSeq.substring(off);
      if (rem.length < consLen * 0.25) break;
      const wa = pairwiseAlign(consU, rem);
      if (wa.alignLen < consLen * 0.25 || wa.identity < 0.35) break;
      const readStart = off + wa.sStart;
      const readEnd = off + wa.sEnd - 1;
      let rawStart, rawEnd;
      if (m.strand === '-') {
        rawStart = m.start + (span - 1 - readEnd);
        rawEnd   = m.start + (span - 1 - readStart);
      } else {
        rawStart = m.start + readStart;
        rawEnd   = m.start + readEnd;
      }
      out.push({
        ...m,
        start: rawStart,
        end: rawEnd,
        length: rawEnd - rawStart + 1,
        identity: wa.identity,
        matches: wa.matches,
        alignLen: wa.alignLen,
      });
      splitOk = true;
      off += wa.sEnd;
    }
    if (!splitOk) {
      console.warn('[splitWideHits] Could not decompose ' + span + 'bp hit at ' + m.start + '-' + m.end);
      out.push(m);
    } else {
      console.log('[splitWideHits] Split ' + span + 'bp hit into ' + out.length + ' sub-hits');
    }
  }
  // Re-sort by start
  out.sort((a, b) => a.start - b.start);
  return out;
}

/**
 * Pairwise SW alignment of two short sequences with full traceback.
 * Returns aligned strings for query and subject.
 */
function pairwiseAlign(query, subject) {
  const match = 2, mismatch = -2, gapOpen = -13, gapExt = -3;
  const qLen = query.length, sLen = subject.length;
  const w = sLen + 1;
  const qU = query.toUpperCase(), sU = subject.toUpperCase();
  const H = new Float32Array((qLen+1)*(sLen+1));
  const E = new Float32Array((qLen+1)*(sLen+1));
  const F = new Float32Array((qLen+1)*(sLen+1));
  const tr = new Uint8Array((qLen+1)*(sLen+1));
  let maxVal=0, maxI=0, maxJ=0;
  for (let i=1;i<=qLen;i++){
    for (let j=1;j<=sLen;j++){
      const idx=i*w+j;
      const sc=(qU[i-1]===sU[j-1]&&qU[i-1]!=='N')?match:mismatch;
      E[idx]=Math.max(H[i*w+(j-1)]+gapOpen+gapExt, E[i*w+(j-1)]+gapExt);
      F[idx]=Math.max(H[(i-1)*w+j]+gapOpen+gapExt, F[(i-1)*w+j]+gapExt);
      const diag=H[(i-1)*w+(j-1)]+sc;
      const best=Math.max(0,diag,E[idx],F[idx]);
      H[idx]=best;
      if(best===0) tr[idx]=0;
      else if(best===diag) tr[idx]=1;
      else if(best===F[idx]) tr[idx]=2;
      else tr[idx]=3;
      if(best>maxVal){maxVal=best;maxI=i;maxJ=j;}
    }
  }
  const qA=[],sA=[];
  let ci=maxI,cj=maxJ,matches=0,alignLen=0;
  while(ci>0&&cj>0&&H[ci*w+cj]>0){
    const t=tr[ci*w+cj];
    if(t===1){qA.push(qU[ci-1]);sA.push(sU[cj-1]);if(qU[ci-1]===sU[cj-1]&&qU[ci-1]!=='N')matches++;alignLen++;ci--;cj--;}
    else if(t===2){qA.push(qU[ci-1]);sA.push('-');alignLen++;ci--;}
    else if(t===3){qA.push('-');sA.push(sU[cj-1]);alignLen++;cj--;}
    else break;
  }
  qA.reverse(); sA.reverse();
  return {qAln:qA.join(''),sAln:sA.join(''),score:maxVal,identity:alignLen>0?matches/alignLen:0,matches,alignLen,sStart:cj,sEnd:maxJ,qStart:ci,qEnd:maxI};
}

/** Merge overlapping hits (like bedtools merge -s -d -1: overlap required, adjacent stays separate).
 *  maxMergeLen: if merging would create a hit longer than this, skip the merge.
 *  Prevents adjacent monomers with trivial 1-bp overlap from fusing into double-width hits.
 *  Never merges hits from different CLsat types. */
function mergeHits(hits, maxMergeLen = Infinity) {
  if (!hits.length) return [];
  console.log('[mergeHits] cap=' + maxMergeLen + ', input=' + hits.length + ' hits');
  const sorted = [...hits].sort((a, b) => a.start - b.start);
  const merged = [{...sorted[0]}];
  for (let i = 1; i < sorted.length; i++) {
    const prev = merged[merged.length - 1];
    const cur = sorted[i];
    const wouldBeEnd = Math.max(prev.end, cur.end);
    const wouldBeLen = wouldBeEnd - prev.start + 1;
    const sameType = (prev.clsat || '?') === (cur.clsat || '?');
    if (sameType && cur.start <= prev.end && wouldBeLen <= maxMergeLen) {
      prev.end = wouldBeEnd;
      prev.length = prev.end - prev.start + 1;
      prev.score = Math.max(prev.score, cur.score);
      prev.identity = Math.max(prev.identity, cur.identity);
      prev.matches = Math.max(prev.matches, cur.matches);
    } else {
      merged.push({...cur});
    }
  }
  // Log any wide hits that survived
  const wide = merged.filter(h => (h.end - h.start + 1) > maxMergeLen);
  if (wide.length > 0) console.warn('[mergeHits] WARNING: ' + wide.length + ' hits wider than cap! Spans:', wide.map(h => h.end - h.start + 1));
  console.log('[mergeHits] output=' + merged.length + ' hits, max span=' + Math.max(...merged.map(h => h.end - h.start + 1)));
  return merged;
}

/** Split hit array into tandem arrays at gaps >100bp, keep only arrays with >=minTandems.
 *  searsat16 uses >=4 per sub-array; we use 3 as default for viewer (more permissive). */
function splitIntoArrays(hits, minTandems = 3) {
  if (!hits.length) return [];
  const arrays = [[hits[0]]];
  for (let i = 1; i < hits.length; i++) {
    const gap = hits[i].start - hits[i-1].end;
    if (gap > 100) {
      arrays.push([hits[i]]);
    } else {
      arrays[arrays.length - 1].push(hits[i]);
    }
  }
  return arrays.filter(a => a.length >= minTandems);
}

/**
 * Split arrays at CLsat-type transition points.
 * When consecutive monomers switch CLsat type (e.g. CLsat3 → CLsat1),
 * split into sub-arrays so each gets its own consensus MSA.
 * Sub-arrays at boundaries (≥1 monomer) are kept; interior sub-arrays need ≥2.
 */
function splitArraysAtTransitions(arrays) {
  const result = [];
  for (const arr of arrays) {
    const hits = arr.hits;
    if (hits.length <= 1) {
      result.push(arr);
      continue;
    }
    // Check if all hits have the same CLsat type
    const types = hits.map(h => h.clsat || '?');
    const allSame = types.every(t => t === types[0]);
    if (allSame) {
      result.push(arr);
      continue;
    }
    // Split at type transitions
    console.log('[transition] Array with mixed types:', types.join(','));
    const subArrays = [{ strand: arr.strand, hits: [hits[0]] }];
    for (let i = 1; i < hits.length; i++) {
      const prevType = hits[i-1].clsat || '?';
      const curType = hits[i].clsat || '?';
      if (curType !== prevType) {
        subArrays.push({ strand: arr.strand, hits: [hits[i]] });
      } else {
        subArrays[subArrays.length - 1].hits.push(hits[i]);
      }
    }
    // Keep sub-arrays: boundary ones (first/last) with ≥1 monomer,
    // interior ones with ≥2 monomers
    for (let si = 0; si < subArrays.length; si++) {
      const sa = subArrays[si];
      const isBoundary = (si === 0 || si === subArrays.length - 1);
      if (sa.hits.length >= 1) {
        result.push(sa);
      }
    }
    console.log('[transition] Split into ' + subArrays.length + ' sub-arrays');
  }
  return result;
}

/**
 * Full client-side monomer analysis replicating searsat16.
 * @param {string} sequence - raw DNA sequence (FASTA with header OK)
 * @param {string} consensusName - CLsat1/CLsat2/CLsat3/CLsat4
 * @param {number} minIdentity - minimum identity to keep a hit (0-1, default 0.75)
 * @returns {object} result with monomers, arrays, stats
 */
/**
 * Run SW-based monomer scan for ONE consensus against a cleaned sequence.
 * Returns an array of hits (not filtered into arrays yet), each tagged with clsat.
 */
function scanOneConsensus(seq, consName, minIdentity) {
  const consensus = CONSENSUS_SEQS[consName];
  if (!consensus) return [];
  const seqLen = seq.length;
  const consLen = consensus.length;
  const Slf = 0.9;
  const minLen = Math.floor(Slf * consLen);

  const fwdHits = smithWaterman(consensus, seq);
  fwdHits.forEach(h => { h.strand = '+'; h.clsat = consName; });

  const rcSeq = revComp(seq);
  const rcHitsRaw = smithWaterman(consensus, rcSeq);
  const rcHits = rcHitsRaw.map(h => {
    const newStart = seqLen - h.end - 1;
    const newEnd = seqLen - h.start - 1;
    return {
      ...h,
      start: newStart,
      end: newEnd,
      length: newEnd - newStart + 1,  // recalculate from transformed coords
      strand: '-',
      clsat: consName,
    };
  });

  let combined = [...fwdHits, ...rcHits]
    .filter(h => h.identity >= minIdentity && h.length >= minLen);

  // Split any raw hits wider than 1.3× consensus (should be rare, but defensive)
  const maxSpan = Math.floor(consLen * 1.3);
  combined = splitWideHits(combined, consensus, seq, maxSpan);

  return combined;
}

/**
 * Resolve overlapping hits from different CLsat scans: keep the one with the best score.
 */
function resolveOverlaps(hits) {
  if (!hits.length) return hits;
  hits.sort((a, b) => a.start - b.start || b.score - a.score);
  const kept = [hits[0]];
  for (let i = 1; i < hits.length; i++) {
    const prev = kept[kept.length - 1];
    const cur = hits[i];
    // If overlapping by >50% of shorter hit, keep best score
    const overlapStart = Math.max(prev.start, cur.start);
    const overlapEnd = Math.min(prev.end, cur.end);
    const overlap = Math.max(0, overlapEnd - overlapStart + 1);
    const shorter = Math.min(prev.length, cur.length);
    if (overlap > shorter * 0.5) {
      // Replace prev if cur is better
      if (cur.score > prev.score) kept[kept.length - 1] = cur;
    } else {
      kept.push(cur);
    }
  }
  return kept;
}

/**
 * After resolveOverlaps determines monomer positions, re-score each hit against
 * ALL consensuses with a fresh pairwise alignment and reassign to the best one.
 * This eliminates fragile assignments caused by the greedy overlap-resolution
 * algorithm, especially at CLsat type boundaries where scores are close.
 */
function reassignBestConsensus(hits, rawSeq) {
  const consNames = Object.keys(CONSENSUS_SEQS);
  if (consNames.length <= 1) return hits;
  for (const hit of hits) {
    // Extract the monomer sequence in reading orientation
    const fwdSlice = rawSeq.substring(hit.start, hit.end + 1);
    const readSeq = hit.strand === '-' ? revComp(fwdSlice) : fwdSlice;
    let bestCn = hit.clsat;
    let bestScore = -Infinity;
    for (const cn of consNames) {
      const cons = CONSENSUS_SEQS[cn];
      if (!cons) continue;
      const aln = pairwiseAlign(cons.toUpperCase(), readSeq);
      if (aln.score > bestScore) {
        bestScore = aln.score;
        bestCn = cn;
      }
    }
    if (bestCn !== hit.clsat) {
      console.log('[reassign] ' + hit.start + '-' + hit.end + ' (' + hit.strand +
        '): ' + hit.clsat + ' -> ' + bestCn +
        ' (score ' + hit.score + ' -> ' + bestScore + ')');
      hit.clsat = bestCn;
      hit.score = bestScore;
    }
  }
  return hits;
}

/**
 * Assign each monomer to its best-matching cluster (cl1–cl9) within its
 * assigned CLsat subfamily. Uses pairwise SW alignment to handle the
 * cl3/cl8 length difference (146 vs 128 bp deletion variant).
 * Adds hit.cluster = 'cl3' etc. and hit.clusterScore.
 */
function assignCluster(hits, rawSeq) {
  for (const hit of hits) {
    const clsatType = hit.clsat;
    const clusters = CLSAT_TO_CLUSTERS[clsatType];
    if (!clusters || clusters.length === 0) {
      hit.cluster = '?';
      hit.clusterScore = 0;
      continue;
    }
    if (clusters.length === 1) {
      hit.cluster = clusters[0];
      hit.clusterScore = hit.score;
      continue;
    }
    // Extract monomer in reading orientation
    const fwdSlice = rawSeq.substring(hit.start, hit.end + 1);
    const readSeq = hit.strand === '-' ? revComp(fwdSlice) : fwdSlice;
    let bestCl = clusters[0];
    let bestScore = -Infinity;
    for (const cl of clusters) {
      const clCons = CLUSTER_SEQS[cl];
      if (!clCons) continue;
      const aln = pairwiseAlign(clCons.toUpperCase(), readSeq);
      if (aln.score > bestScore) {
        bestScore = aln.score;
        bestCl = cl;
      }
    }
    hit.cluster = bestCl;
    hit.clusterScore = bestScore;
  }
  return hits;
}

function analyzeMonomersSW(sequence, consensusName, minIdentity = 0.75) {
  const seq = sequence.replace(/^>.*\n/gm, '').replace(/\s/g, '').toUpperCase();
  const seqLen = seq.length;

  if (seqLen > 50000) {
    console.warn("[SW] Large sequence (" + seqLen + " bp) — analysis may take a while");
  }
  if (seqLen > 200000) {
    return { success: false, message: "Sequence too large (" + (seqLen/1000).toFixed(0) + " kb). Zoom in to <50 kb first." };
  }

  // Determine which consensus(es) to scan
  // Always scan ALL consensuses to detect transition zones between CLsat types
  let scanNames = Object.keys(CONSENSUS_SEQS);
  console.log("[SW] Scanning all consensuses:", scanNames.join(', ') + " (assigned: " + consensusName + ")");

  // Scan with each consensus
  let allHits = [];
  for (const cn of scanNames) {
    const hits = scanOneConsensus(seq, cn, minIdentity);
    console.log("[SW] " + cn + ": " + hits.length + " raw hits");
    allHits.push(...hits);
  }

  // Always resolve overlaps across consensuses (keep best score at each position)
  allHits = resolveOverlaps(allHits);
  console.log("[SW] After overlap resolution: " + allHits.length + " hits");

  // Re-score each hit against ALL consensuses to fix fragile boundary assignments
  allHits = reassignBestConsensus(allHits, seq);

  // Assign cluster within each hit's CLsat type
  allHits = assignCluster(allHits, seq);

  allHits.sort((a, b) => a.start - b.start);

  console.log("[SW] Sequence: " + seqLen + " bp, Filtered hits: " + allHits.length);

  if (allHits.length === 0) {
    return {
      success: false,
      message: "No monomers found with >=" + (minIdentity*100).toFixed(0) + "% identity",
      monomer_count: 0,
      monomers: [],
      arrays: [],
    };
  }

  // Separate by strand, merge (with max-length cap), then split into arrays
  const maxConsLen = Math.max(...scanNames.map(cn => (CONSENSUS_SEQS[cn] || '').length), 100);
  const maxMergeLen = Math.floor(maxConsLen * 1.3);  // 1.3× consensus = ~190bp for CLsat1
  let plusHits = mergeHits(allHits.filter(h => h.strand === '+'), maxMergeLen);
  let minusHits = mergeHits(allHits.filter(h => h.strand === '-'), maxMergeLen);

  // Post-merge safety: split any surviving wide hits
  const primaryCons = CONSENSUS_SEQS[scanNames[0]] || '';
  plusHits = splitWideHits(plusHits, primaryCons, seq, maxMergeLen);
  minusHits = splitWideHits(minusHits, primaryCons, seq, maxMergeLen);

  const plusArrays = splitIntoArrays(plusHits, 3);
  const minusArrays = splitIntoArrays(minusHits, 3);

  console.log("[SW] + strand: " + plusHits.length + " merged -> " + plusArrays.length + " arrays");
  console.log("[SW] - strand: " + minusHits.length + " merged -> " + minusArrays.length + " arrays");

  // Combine results
  let allArrays = [
    ...plusArrays.map(a => ({ strand: '+', hits: a })),
    ...minusArrays.map(a => ({ strand: '-', hits: a })),
  ].sort((a, b) => a.hits[0].start - b.hits[0].start);

  // Split arrays at CLsat type transition points
  allArrays = splitArraysAtTransitions(allArrays);

  const allMonomers = allArrays.flatMap(a => a.hits.map(h => ({...h, strand: a.strand})));

  const totalIdent = allMonomers.reduce((s,m) => s + m.identity, 0);
  const avgIdent = allMonomers.length > 0 ? totalIdent / allMonomers.length : 0;

  // Determine consensus_name for the result
  const usedClsats = [...new Set(allMonomers.map(m => m.clsat))];
  const resultConsName = usedClsats.length === 1 ? usedClsats[0] : usedClsats.join('+');

  return {
    success: true,
    message: "Found " + allMonomers.length + " monomers in " + allArrays.length + " tandem array(s)" +
             (usedClsats.length > 1 ? " (" + usedClsats.join(', ') + ")" : ""),
    monomer_count: allMonomers.length,
    array_count: allArrays.length,
    consensus_name: resultConsName,
    consensus_names: usedClsats,
    consensus_length: CONSENSUS_SEQS[usedClsats[0]]?.length || 146,
    avg_identity: avgIdent,
    monomers: allMonomers,
    arrays: allArrays,
  };
}

/**
 * Draw a visual monomer map with directional arrows.
 * @param {string} containerId - DOM id of the container div
 * @param {object} result - analyzeMonomersSW result object
 * @param {number} locusStart - genomic start coordinate
 * @param {number} locusEnd - genomic end coordinate
 */
function drawMonomerMap(containerId, result, locusStart, locusEnd) {
  const container = document.getElementById(containerId);
  if (!container || !result || !result.success || !result.arrays.length) {
    if (container) container.innerHTML = '';
    return;
  }

  const margin = { left: 50, right: 20, top: 12, bottom: 24 };
  const W = Math.max(container.clientWidth || 500, 400);
  const trackH = 22;
  const gap = 6;
  // One track per array
  const nTracks = result.arrays.length;
  const H = margin.top + nTracks * (trackH + gap) + margin.bottom;
  const innerW = W - margin.left - margin.right;

  container.innerHTML = '';
  const svg = d3.select('#' + containerId).append('svg')
    .attr('width', W).attr('height', H)
    .style('background', '#070b12').style('border-radius', '6px');

  // X scale: genomic coordinates
  const x = d3.scaleLinear()
    .domain([locusStart, locusEnd])
    .range([margin.left, margin.left + innerW]);

  // Axis
  const axisG = svg.append('g')
    .attr('transform', 'translate(0,' + (H - margin.bottom) + ')');
  const axis = d3.axisBottom(x).ticks(6).tickFormat(d => (d/1e6).toFixed(3) + 'M');
  axisG.call(axis);
  axisG.selectAll('text').style('fill', '#9ca3af').style('font-size', '9px');
  axisG.selectAll('line, path').style('stroke', '#374151');

  // Color + arrow function
  const plusColor = '#34d399';
  const minusColor = '#f472b6';

  result.arrays.forEach((arr, ai) => {
    const yTop = margin.top + ai * (trackH + gap);
    const strand = arr.strand;
    const color = strand === '+' ? plusColor : minusColor;

    // Track label
    svg.append('text')
      .attr('x', margin.left - 6)
      .attr('y', yTop + trackH / 2 + 3)
      .attr('text-anchor', 'end')
      .attr('class', 'monomerMap-label')
      .text(strand === '+' ? '→+' : '←−');

    // Draw each monomer as a directed arrow/rectangle
    arr.hits.forEach((m, mi) => {
      const gStart = m.start + locusStart;
      const gEnd = m.end + locusStart;
      const xStart = x(gStart);
      const xEnd = x(gEnd);
      const w = Math.max(xEnd - xStart, 2); // minimum 2px
      const arrowTip = Math.min(6, w * 0.3);

      // Color by CLsat type
      const clsatColor = CLSAT_COLORS[m.clsat] || color;

      // Build arrow polygon
      let points;
      if (strand === '+') {
        // Right-pointing arrow
        points = [
          [xStart, yTop],
          [xStart + w - arrowTip, yTop],
          [xStart + w, yTop + trackH / 2],
          [xStart + w - arrowTip, yTop + trackH],
          [xStart, yTop + trackH]
        ];
      } else {
        // Left-pointing arrow
        points = [
          [xStart + arrowTip, yTop],
          [xStart + w, yTop],
          [xStart + w, yTop + trackH],
          [xStart + arrowTip, yTop + trackH],
          [xStart, yTop + trackH / 2]
        ];
      }

      const pctId = (m.identity * 100).toFixed(1);
      const clsatLabel = m.clsat || '?';
      const clusterLabel = m.cluster ? '/' + m.cluster : '';
      const monId = 'mon-' + ai + '-' + mi;
      svg.append('polygon')
        .attr('points', points.map(p => p.join(',')).join(' '))
        .attr('fill', clsatColor)
        .attr('stroke', d3.color(clsatColor).darker(0.5))
        .attr('class', 'monomerMap-arrow')
        .attr('data-monid', monId)
        .on('mouseenter', function() { highlightMonomer(monId, true); })
        .on('mouseleave', function() { highlightMonomer(null, false); })
        .append('title')
        .text(clsatLabel + clusterLabel + ' #' + (mi + 1) + ': ' + gStart.toLocaleString() + '-' + gEnd.toLocaleString() +
              ' (' + m.length + ' bp, ' + pctId + '% identity)');
    });

    // Array bracket label
    const arrStart = arr.hits[0].start + locusStart;
    const arrEnd = arr.hits[arr.hits.length - 1].end + locusStart;
    svg.append('text')
      .attr('x', x((arrStart + arrEnd) / 2))
      .attr('y', yTop - 2)
      .attr('text-anchor', 'middle')
      .style('fill', color).style('font-size', '8px').style('font-family', 'ui-monospace, monospace')
      .text('Array ' + (ai + 1) + ' (' + arr.hits.length + '×' + strand + ')');
  });
}

/**
 * Render monomer alignment as MSA with integrated flanks.
 * Per-ARRAY blocks showing consensus-anchored MSA with ±100bp flanks
 * on the first/last monomers to visualize satellite-to-flank transitions.
 */
function renderMonomerMSA(containerId, result, rawSeq, genomicStart, scaffoldName) {
  const container = document.getElementById(containerId);
  if (!container || !result || !result.success || !result.arrays.length) {
    if (container) container.innerHTML = '';
    return;
  }
  const gOff = genomicStart || 0;
  const scfName = scaffoldName || '';
  const ntCol = {A:'#27ae60',C:'#2980b9',G:'#d35400',T:'#c0392b',
                 a:'#27ae60',c:'#2980b9',g:'#d35400',t:'#c0392b'};
  const FLANK_SIZE = 300;

  // Helper: render one base span with mode
  // mode: 'match', 'mismatch', 'gap', 'flank', 'overhang', 'spacer'
  function baseSpan(b, c, mode, title) {
    const t = title ? ' title="' + title + '"' : '';
    if (mode === 'flank') return '<span class="msaBase"' + t + ' style="background:#12151f; color:' + (ntCol[b]||'#555') + '; opacity:0.8;">' + b.toLowerCase() + '</span>';
    if (mode === 'overhang') return '<span class="msaBase"' + t + ' style="background:#151520; color:' + (ntCol[b]||'#777') + ';">' + b + '</span>';
    if (mode === 'spacer') return '<span class="msaBase"' + t + ' style="background:#0f0f1a; color:' + (ntCol[b]||'#555') + '; opacity:0.7;">' + b.toLowerCase() + '</span>';
    if (b === '-') return '<span class="msaBase msaGap"' + t + '>-</span>';
    if (b === c) return '<span class="msaBase msaMatch"' + t + '>' + b + '</span>';
    return '<span class="msaBase msaMismatch"' + t + ' style="background:#2a0c0c; color:' + (ntCol[b]||'#888') + ';">' + b + '</span>';
  }
  const sepSpan = '<span class="msaBase" style="color:#f59e0b; font-weight:bold;">\u2502</span>';

  let html = '';
  let globalIdx = 0;
  const fastaLines = [];

  // Per-ARRAY MSA blocks with integrated flanks
  result.arrays.forEach((arr, ai) => {
    const strand = arr.strand;
    const firstStart = arr.hits[0].start;
    const lastEnd = arr.hits[arr.hits.length - 1].end;

    // Dominant CLsat for this array
    const clsatCounts = {};
    arr.hits.forEach(m => { const c = m.clsat || '?'; clsatCounts[c] = (clsatCounts[c]||0)+1; });
    const dominantClsat = Object.entries(clsatCounts).sort((a,b) => b[1]-a[1])[0][0];
    // Dominant cluster for this array
    const clusterCounts = {};
    arr.hits.forEach(m => { if (m.cluster) clusterCounts[m.cluster] = (clusterCounts[m.cluster]||0)+1; });
    const dominantCluster = Object.keys(clusterCounts).length > 0 ? Object.entries(clusterCounts).sort((a,b) => b[1]-a[1])[0][0] : '';
    const consensus = CONSENSUS_SEQS[dominantClsat];
    if (!consensus) return;
    const consU = consensus.toUpperCase();
    const consLen = consU.length;
    const clsatColor = CLSAT_COLORS[dominantClsat] || '#a855f7';

    // Extract flanks (in genomic/forward orientation)
    const leftFlankStart = Math.max(0, firstStart - FLANK_SIZE);
    const leftFlank = rawSeq.substring(leftFlankStart, firstStart);
    const rightFlankEnd = Math.min(rawSeq.length, lastEnd + 1 + FLANK_SIZE);
    const rightFlank = rawSeq.substring(lastEnd + 1, rightFlankEnd);

    // For minus-strand arrays, the "left" genomic flank is actually the
    // 3' end (right side after revcomp), and vice versa.
    // We orient flanks to match the monomer reading direction.
    let flankBefore, flankAfter;
    if (strand === '-') {
      flankBefore = revComp(rightFlank); // genomic right = reading-order left
      flankAfter = revComp(leftFlank);   // genomic left = reading-order right
    } else {
      flankBefore = leftFlank;
      flankAfter = rightFlank;
    }
    const nBeforeOrig = flankBefore.length;
    const nAfterOrig = flankAfter.length;

    html += '<div style="margin-top:10px; color:' + clsatColor + '; font-weight:bold; font-size:10px;">';
    html += 'Array ' + (ai+1) + ' \u2014 ' + arr.hits.length + ' monomers (' + strand + ' strand, ' + dominantClsat + ') \u2014 flanks + consensus-anchored MSA';
    html += '</div>';
    html += '<div class="msaBlock">';

    // --- SAFETY: Re-split any hit wider than 1.3× consensus ---
    // Uses the shared splitWideHits function. Defense-in-depth for any
    // double-width hits that survived mergeHits + analyzeMonomersSW splitting.
    const maxHitLen = Math.floor(consLen * 1.3);
    let displayHits = splitWideHits(arr.hits.slice(), consensus, rawSeq, maxHitLen);
    // splitWideHits re-sorts ascending by genomic start.
    // For minus-strand, reverse to biological 5'→3' order AFTER the re-sort
    // so that isFirst (mi=0) = biological 5' start and isLast = biological 3' end.
    if (strand === '-') displayHits.reverse();
    // Re-create displayIndices to match (indices are only used for origIdx / monId)
    const displayIndicesNew = displayHits.map((_,i) => i);

    // Align each monomer and build rows
    const projRows = [];
    displayHits.forEach((m, mi) => {
      globalIdx++;
      const origIdx = displayIndicesNew[mi];
      let monSeq = rawSeq.substring(m.start, m.end + 1);
      if (strand === '-') monSeq = revComp(monSeq);

      // Extend boundary monomers with flanks
      let extLeft = '';
      let extRight = '';
      if (mi === 0 && nBeforeOrig > 0) extLeft = flankBefore;
      if (mi === displayHits.length - 1 && nAfterOrig > 0) extRight = flankAfter;

      const extLeftLen = extLeft.length;
      const monSeqLen = monSeq.length;
      const monEndInExt = extLeftLen + monSeqLen;

      const extSeq = extLeft + monSeq + extRight;
      const aln = pairwiseAlign(consensus, extSeq);

      // Build consensus-position-aware projection
      const proj = new Array(consLen).fill('-');
      let qPos = aln.qStart;
      for (let k = 0; k < aln.qAln.length; k++) {
        if (aln.qAln[k] !== '-') {
          if (qPos < consLen) proj[qPos] = aln.sAln[k];
          qPos++;
        }
      }

      // Separate unaligned portions into monomer overhang vs actual flank
      let flankLeftStr = '', monOverLeft = '', monOverRight = '', flankRightStr = '';

      if (aln.sStart > 0) {
        if (extLeftLen > 0) {
          const flankEnd = Math.min(aln.sStart, extLeftLen);
          flankLeftStr = extSeq.substring(0, flankEnd);
          if (aln.sStart > extLeftLen) monOverLeft = extSeq.substring(extLeftLen, aln.sStart);
        } else {
          monOverLeft = extSeq.substring(0, aln.sStart);
        }
      }

      if (aln.sEnd < extSeq.length) {
        if (extRight.length > 0) {
          if (aln.sEnd < monEndInExt) monOverRight = extSeq.substring(aln.sEnd, monEndInExt);
          flankRightStr = extSeq.substring(monEndInExt);
        } else {
          monOverRight = extSeq.substring(aln.sEnd);
        }
      }

      // --- FILL UP: Force-place overhang into trailing/leading consensus gaps ---
      // This fixes the contiguity bug where SW truncates monomer ends
      // and those bases disappear from the alignment.
      if (monOverLeft.length > 0 && aln.qStart > 0) {
        const fillLead = Math.min(monOverLeft.length, aln.qStart);
        for (let k = 0; k < fillLead; k++) {
          proj[aln.qStart - fillLead + k] = monOverLeft[monOverLeft.length - fillLead + k];
        }
        monOverLeft = monOverLeft.substring(0, monOverLeft.length - fillLead);
      }
      if (monOverRight.length > 0 && aln.qEnd < consLen) {
        const fillTrail = Math.min(monOverRight.length, consLen - aln.qEnd);
        for (let k = 0; k < fillTrail; k++) {
          proj[aln.qEnd + k] = monOverRight[k];
        }
        monOverRight = monOverRight.substring(fillTrail);
      }

      // Detect spacer between consecutive monomers
      let spacerSeq = '';
      let spacerLen = 0;
      if (mi > 0) {
        const prevM = displayHits[mi - 1];
        const gapStartGenomic = Math.min(prevM.end, m.end) + 1;
        const gapEndGenomic = Math.max(prevM.start, m.start) - 1;
        if (gapEndGenomic >= gapStartGenomic) {
          spacerLen = gapEndGenomic - gapStartGenomic + 1;
          spacerSeq = rawSeq.substring(gapStartGenomic, gapEndGenomic + 1);
          if (strand === '-') spacerSeq = revComp(spacerSeq);
        }
      }

      const strandChar = strand === '+' ? '+' : '-';
      const clsatLabel = m.clsat || dominantClsat;
      const clusterTag = m.cluster ? '/' + m.cluster : '';
      const gStart = m.start + gOff;
      const gEnd = m.end + gOff;
      const label = '#' + globalIdx + ' ' + gStart + '-' + gEnd + '(' + strandChar + ')';
      const hoverTitle = scfName + ':' + gStart + '-' + gEnd + ' (' + clsatLabel + clusterTag + ', ' + (m.end - m.start + 1) + ' bp, ' + (aln.identity*100).toFixed(1) + '%)';
      const monId = 'mon-' + ai + '-' + origIdx;

      projRows.push({
        name: label, hoverTitle, monId,
        bases: proj, identity: aln.identity,
        flankLeftStr, monOverLeft, monOverRight, flankRightStr,
        isFirst: mi === 0, isLast: mi === displayHits.length - 1,
        clsat: clsatLabel,
        cluster: m.cluster || '',
        spacerSeq, spacerLen,
        gStart, gEnd,
      });
    });

    // --- REFINE STEP: Redistribute trailing overhangs (searsat16 logic) ---
    for (let i = 0; i < projRows.length - 1; i++) {
      const overhang = projRows[i].monOverRight;
      if (overhang.length === 0) continue;
      if (projRows[i + 1].spacerLen > 0) continue;
      let leadGaps = 0;
      for (let k = 0; k < consLen; k++) {
        if (projRows[i + 1].bases[k] === '-') leadGaps++;
        else break;
      }
      const toMove = Math.min(overhang.length, leadGaps);
      if (toMove > 0) {
        for (let k = 0; k < toMove; k++) {
          projRows[i + 1].bases[k] = overhang[k];
        }
        projRows[i].monOverRight = overhang.substring(toMove);
      }
    }

    // --- ABSORB SHORT SPACERS into trailing/leading gaps ---
    // If a spacer is short (≤10bp), try to redistribute its bases:
    // 1) Fill trailing gaps of the previous monomer row
    // 2) Fill leading gaps of the current (next) monomer row
    // If fully consumed, clear spacerLen so no spacer line is rendered.
    for (let i = 0; i < projRows.length; i++) {
      if (projRows[i].spacerLen === 0 || projRows[i].spacerLen > 10) continue;
      let sp = projRows[i].spacerSeq.toUpperCase();
      // Fill trailing gaps of the PREVIOUS row
      if (i > 0) {
        let trailGaps = 0;
        for (let k = consLen - 1; k >= 0; k--) {
          if (projRows[i - 1].bases[k] === '-') trailGaps++;
          else break;
        }
        const fillTrail = Math.min(sp.length, trailGaps);
        if (fillTrail > 0) {
          for (let k = 0; k < fillTrail; k++) {
            projRows[i - 1].bases[consLen - trailGaps + k] = sp[k];
          }
          sp = sp.substring(fillTrail);
        }
      }
      // Fill leading gaps of THIS row
      if (sp.length > 0) {
        let leadGaps = 0;
        for (let k = 0; k < consLen; k++) {
          if (projRows[i].bases[k] === '-') leadGaps++;
          else break;
        }
        const fillLead = Math.min(sp.length, leadGaps);
        if (fillLead > 0) {
          for (let k = 0; k < fillLead; k++) {
            projRows[i].bases[leadGaps - fillLead + k] = sp[sp.length - fillLead + k];
          }
          sp = sp.substring(0, sp.length - fillLead);
        }
      }
      // Update spacer
      projRows[i].spacerSeq = sp;
      projRows[i].spacerLen = sp.length;
    }

    // --- ITERATIVE BOUNDARY PARTIAL REPEAT DETECTION ---
    // For reading-last: keep pulling CLsat partial repeats from monOverRight + flankRightStr
    // until no more match. This handles cases where the flank contains multiple monomers.
    for (let _iter = 0; _iter < 10; _iter++) {
      const lastRow = projRows[projRows.length - 1];
      if (!lastRow.isLast) break;
      const boundarySeq = lastRow.monOverRight + lastRow.flankRightStr;
      if (boundarySeq.length <= 10) break;
      const bAln = pairwiseAlign(consensus, boundarySeq);
      // Accept short partials (>10bp) if identity is high (>80%),
      // or longer partials (>20bp) at moderate identity (>50%)
      const bAccept = (bAln.alignLen > 10 && bAln.identity > 0.8) || (bAln.alignLen > 20 && bAln.identity > 0.5);
      if (!bAccept) break;

      // Cross-consensus check: reject if a different CLsat type matches better
      let dominated = false;
      for (const otherName of Object.keys(CONSENSUS_SEQS)) {
        if (otherName === dominantClsat) continue;
        const otherCons = CONSENSUS_SEQS[otherName];
        const otherAln = pairwiseAlign(otherCons, boundarySeq);
        if (otherAln.score > bAln.score && otherAln.identity > bAln.identity) {
          console.log('[boundary] Right partial rejected: ' + dominantClsat + ' score=' + bAln.score.toFixed(0) + ' id=' + (bAln.identity*100).toFixed(0) + '% < ' + otherName + ' score=' + otherAln.score.toFixed(0) + ' id=' + (otherAln.identity*100).toFixed(0) + '%');
          dominated = true;
          break;
        }
      }
      if (dominated) break;

      globalIdx++;
      const partProj = new Array(consLen).fill('-');
      let pq = bAln.qStart;
      for (let k = 0; k < bAln.qAln.length; k++) {
        if (bAln.qAln[k] !== '-') {
          if (pq < consLen) partProj[pq] = bAln.sAln[k];
          pq++;
        }
      }
      // Fill leading gaps with any pre-alignment bases
      const preBases = boundarySeq.substring(0, bAln.sStart);
      let preUsed = 0;
      if (preBases.length > 0 && bAln.qStart > 0) {
        preUsed = Math.min(preBases.length, bAln.qStart);
        for (let k = 0; k < preUsed; k++) {
          partProj[bAln.qStart - preUsed + k] = preBases[preBases.length - preUsed + k];
        }
      }
      // Put any remaining preBases back into previous row's monOverRight
      const preRemain = preBases.substring(0, preBases.length - preUsed);
      if (preRemain.length > 0) {
        lastRow.monOverRight = preRemain;
      } else {
        lastRow.monOverRight = '';
      }
      let trueFlank = boundarySeq.substring(bAln.sEnd);
      // Fill trailing consensus gaps with post-alignment bases
      if (trueFlank.length > 0 && bAln.qEnd < consLen) {
        const fill = Math.min(trueFlank.length, consLen - bAln.qEnd);
        for (let k = 0; k < fill; k++) partProj[bAln.qEnd + k] = trueFlank[k];
        trueFlank = trueFlank.substring(fill);
      }
      projRows.push({
        name: '#' + globalIdx + ' partial(' + lastRow.clsat[lastRow.clsat.length-1] + ')',
        hoverTitle: 'Partial repeat at boundary',
        monId: lastRow.monId + '-partial-' + _iter,
        bases: partProj, identity: bAln.identity,
        flankLeftStr: '', monOverLeft: '',
        monOverRight: '', flankRightStr: trueFlank,
        isFirst: false, isLast: true,
        clsat: lastRow.clsat,
        spacerLen: 0, spacerSeq: '',
        gStart: lastRow.gEnd, gEnd: lastRow.gEnd,
      });
      lastRow.flankRightStr = '';
      lastRow.isLast = false;
    }

    // Same iterative detection for reading-first
    for (let _iter = 0; _iter < 10; _iter++) {
      const firstRow = projRows[0];
      if (!firstRow.isFirst) break;
      const boundarySeq = firstRow.flankLeftStr + firstRow.monOverLeft;
      if (boundarySeq.length <= 10) break;
      const bAln = pairwiseAlign(consensus, boundarySeq);
      const bAccept = (bAln.alignLen > 10 && bAln.identity > 0.8) || (bAln.alignLen > 20 && bAln.identity > 0.5);
      if (!bAccept) break;

      // Cross-consensus check: reject if a different CLsat type matches better
      let dominated = false;
      for (const otherName of Object.keys(CONSENSUS_SEQS)) {
        if (otherName === dominantClsat) continue;
        const otherCons = CONSENSUS_SEQS[otherName];
        const otherAln = pairwiseAlign(otherCons, boundarySeq);
        if (otherAln.score > bAln.score && otherAln.identity > bAln.identity) {
          console.log('[boundary] Left partial rejected: ' + dominantClsat + ' score=' + bAln.score.toFixed(0) + ' id=' + (bAln.identity*100).toFixed(0) + '% < ' + otherName + ' score=' + otherAln.score.toFixed(0) + ' id=' + (otherAln.identity*100).toFixed(0) + '%');
          dominated = true;
          break;
        }
      }
      if (dominated) break;

      globalIdx++;
      const partProj = new Array(consLen).fill('-');
      let pq = bAln.qStart;
      for (let k = 0; k < bAln.qAln.length; k++) {
        if (bAln.qAln[k] !== '-') {
          if (pq < consLen) partProj[pq] = bAln.sAln[k];
          pq++;
        }
      }
      // Fill trailing gaps with post-alignment bases
      const postBases = boundarySeq.substring(bAln.sEnd);
      let postUsed = 0;
      if (postBases.length > 0 && bAln.qEnd < consLen) {
        postUsed = Math.min(postBases.length, consLen - bAln.qEnd);
        for (let k = 0; k < postUsed; k++) {
          partProj[bAln.qEnd + k] = postBases[k];
        }
      }
      // Put any remaining postBases back into first row's monOverLeft
      const postRemain = postBases.substring(postUsed);
      if (postRemain.length > 0) {
        firstRow.monOverLeft = postRemain;
      } else {
        firstRow.monOverLeft = '';
      }
      let trueFlank = boundarySeq.substring(0, bAln.sStart);
      // Fill leading consensus gaps with pre-alignment bases
      let preUsed = 0;
      if (trueFlank.length > 0 && bAln.qStart > 0) {
        preUsed = Math.min(trueFlank.length, bAln.qStart);
        for (let k = 0; k < preUsed; k++) partProj[bAln.qStart - preUsed + k] = trueFlank[trueFlank.length - preUsed + k];
        trueFlank = trueFlank.substring(0, trueFlank.length - preUsed);
      }
      projRows.unshift({
        name: '#0 partial(' + firstRow.clsat[firstRow.clsat.length-1] + ')',
        hoverTitle: 'Partial repeat at boundary',
        monId: firstRow.monId + '-partial-' + _iter,
        bases: partProj, identity: bAln.identity,
        flankLeftStr: trueFlank, monOverLeft: '',
        monOverRight: '', flankRightStr: '',
        isFirst: true, isLast: false,
        clsat: firstRow.clsat,
        spacerLen: 0, spacerSeq: '',
        gStart: firstRow.gStart, gEnd: firstRow.gStart,
      });
      firstRow.flankLeftStr = '';
      firstRow.monOverLeft = '';
      firstRow.isFirst = false;
    }

    // --- Absorb very short flanks (<10bp) into the boundary row projection ---
    // These are usually scaffold-edge remnants of CLsat, not real flanks.
    const firstRowFinal = projRows.find(r => r.isFirst);
    if (firstRowFinal && firstRowFinal.flankLeftStr.length > 0 && firstRowFinal.flankLeftStr.length < 10) {
      let leadGaps = 0;
      for (let k = 0; k < consLen; k++) { if (firstRowFinal.bases[k] === '-') leadGaps++; else break; }
      if (leadGaps > 0) {
        const fl = firstRowFinal.flankLeftStr;
        const fill = Math.min(fl.length, leadGaps);
        for (let k = 0; k < fill; k++) firstRowFinal.bases[leadGaps - fill + k] = fl[fl.length - fill + k];
        firstRowFinal.flankLeftStr = fl.substring(0, fl.length - fill);
      }
    }
    const lastRowFinal = projRows.find(r => r.isLast);
    if (lastRowFinal && lastRowFinal.flankRightStr.length > 0 && lastRowFinal.flankRightStr.length < 10) {
      let trailGaps = 0;
      for (let k = consLen - 1; k >= 0; k--) { if (lastRowFinal.bases[k] === '-') trailGaps++; else break; }
      if (trailGaps > 0) {
        const fl = lastRowFinal.flankRightStr;
        const fill = Math.min(fl.length, trailGaps);
        for (let k = 0; k < fill; k++) lastRowFinal.bases[consLen - trailGaps + k] = fl[k];
        lastRowFinal.flankRightStr = fl.substring(fill);
      }
    }

    // --- Compute actual flank column widths from processed rows ---
    const firstRowDisp = projRows.find(r => r.isFirst);
    const lastRowDisp = projRows.find(r => r.isLast);
    const nBefore = firstRowDisp ? firstRowDisp.flankLeftStr.length : 0;
    const nAfter = lastRowDisp ? lastRowDisp.flankRightStr.length : 0;

    // Scale ruler — right-justified tick labels
    html += '<div class="msaRow"><span class="msaName"></span>';
    // left flank ruler
    { const r = new Array(nBefore).fill(' ');
      for (let k = 0; k < nBefore; k++) { const p = -(nBefore - k); if (p % 10 === 0 && p !== 0) { const s = String(p); const st = k - s.length + 1; if (st >= 0) for (let d = 0; d < s.length; d++) r[st+d] = s[d]; } }
      for (let k = 0; k < nBefore; k++) html += '<span class="msaBase" style="color:' + (r[k] !== ' ' ? '#555' : 'transparent') + ';">' + r[k] + '</span>';
    }
    if (nBefore > 0) html += '<span class="msaBase" style="color:#f59e0b;">\u2502</span>';
    // consensus ruler
    { const r = new Array(consLen).fill(' ');
      for (let k = 0; k < consLen; k++) { const p = k + 1; if (p % 10 === 0) { const s = String(p); const st = k - s.length + 1; if (st >= 0) for (let d = 0; d < s.length; d++) r[st+d] = s[d]; } else if (p % 5 === 0 && r[k] === ' ') r[k] = '.'; }
      for (let k = 0; k < consLen; k++) { if (r[k] === '.') html += '<span class="msaBase" style="color:#333;">.</span>'; else if (r[k] !== ' ') html += '<span class="msaBase" style="color:#555;">' + r[k] + '</span>'; else html += '<span class="msaBase"> </span>'; }
    }
    if (nAfter > 0) html += '<span class="msaBase" style="color:#f59e0b;">\u2502</span>';
    // right flank ruler
    { const r = new Array(nAfter).fill(' ');
      for (let k = 0; k < nAfter; k++) { const p = k + 1; if (p % 10 === 0) { const s = String(p); const st = k - s.length + 1; if (st >= 0) for (let d = 0; d < s.length; d++) r[st+d] = s[d]; } }
      for (let k = 0; k < nAfter; k++) html += '<span class="msaBase" style="color:' + (r[k] !== ' ' ? '#555' : 'transparent') + ';">' + r[k] + '</span>';
    }
    html += '</div>';

    // Consensus row (no pipe separators — just dots for flank area)
    html += '<div class="msaRow"><span class="msaName" style="color:' + clsatColor + '; font-weight:bold;">' + dominantClsat + (dominantCluster ? '/' + dominantCluster : '') + '</span>';
    for (let k = 0; k < nBefore; k++) html += '<span class="msaBase" style="color:#1a1a2e;">\u00b7</span>';
    if (nBefore > 0) html += '<span class="msaBase" style="color:#1a1a2e;">\u00b7</span>';
    for (let k = 0; k < consLen; k++) html += '<span class="msaBase msaCons">' + consU[k] + '</span>';
    if (nAfter > 0) html += '<span class="msaBase" style="color:#1a1a2e;">\u00b7</span>';
    for (let k = 0; k < nAfter; k++) html += '<span class="msaBase" style="color:#1a1a2e;">\u00b7</span>';
    html += '</div>';

    // --- Build FASTA data for copy (includes flanks) ---
    const arrFastaLines = [];
    arrFastaLines.push('>consensus_' + dominantClsat);
    arrFastaLines.push(consU);
    projRows.forEach(row => {
      let seqStr = '';
      if (row.isFirst && row.flankLeftStr) seqStr += row.flankLeftStr.toLowerCase();
      seqStr += row.bases.join('');
      if (row.monOverRight.length > 0) seqStr += row.monOverRight;
      if (row.isLast && row.flankRightStr) seqStr += row.flankRightStr.toLowerCase();
      arrFastaLines.push('>' + row.name.replace(/\s+/g, '_'));
      arrFastaLines.push(seqStr);
    });
    arrFastaLines.push('');
    fastaLines.push(...arrFastaLines);

    // --- Monomer rows ---
    projRows.forEach((row, ri) => {
      // Insert spacer row if there's a gap between this and previous monomer
      if (row.spacerLen > 0) {
        // Check if the spacer is actually a degraded CLsat monomer
        const spU = row.spacerSeq.toUpperCase();
        const spAln = pairwiseAlign(consensus, spU);
        if (spAln.identity > 0.4 && spAln.alignLen > 30) {
          // Render as degraded monomer projected onto consensus columns
          const degProj = new Array(consLen).fill('-');
          let dpq = spAln.qStart;
          for (let k = 0; k < spAln.qAln.length; k++) {
            if (spAln.qAln[k] !== '-') {
              if (dpq < consLen) degProj[dpq] = spAln.sAln[k];
              dpq++;
            }
          }
          // Fill-up leading gaps
          if (spAln.sStart > 0 && spAln.qStart > 0) {
            const ov = spU.substring(0, spAln.sStart);
            const fill = Math.min(ov.length, spAln.qStart);
            for (let k = 0; k < fill; k++) degProj[spAln.qStart - fill + k] = ov[ov.length - fill + k];
          }
          // Fill-up trailing gaps
          if (spAln.sEnd < spU.length && spAln.qEnd < consLen) {
            const ov = spU.substring(spAln.sEnd);
            const fill = Math.min(ov.length, consLen - spAln.qEnd);
            for (let k = 0; k < fill; k++) degProj[spAln.qEnd + k] = ov[k];
          }
          html += '<div class="msaRow"><span class="msaName" style="color:#666;">\u2020 ' + row.spacerLen + 'bp degraded</span>';
          if (nBefore > 0) { for (let k = 0; k <= nBefore; k++) html += '<span class="msaBase"> </span>'; }
          let gfp = 0;
          for (let k = 0; k < consLen; k++) {
            const b = degProj[k];
            let tip = '';
            if (b !== '-') { gfp++; tip = 'pos ' + gfp; }
            html += baseSpan(b, consU[k], null, tip);
          }
          html += '<span class="msaIdent" style="color:#666;">' + (spAln.identity*100).toFixed(0) + '%</span>';
          html += '</div>';
        } else {
          // Regular spacer display (non-CLsat content)
          html += '<div class="msaRow"><span class="msaName" style="color:#666;">\u2502 ' + row.spacerLen + 'bp spacer</span>';
          if (nBefore > 0) { for (let k = 0; k <= nBefore; k++) html += '<span class="msaBase"> </span>'; }
          let displaySpacer = row.spacerSeq.toUpperCase();
          if (row.spacerLen > 100) {
            const left50 = displaySpacer.substring(0, 50);
            const right50 = displaySpacer.substring(displaySpacer.length - 50);
            const gapLabel = '(' + (row.spacerLen - 100) + 'bp)';
            for (let k = 0; k < 50; k++) html += baseSpan(left50[k], '', 'spacer', 'spacer pos ' + (k+1));
            html += '<span class="msaBase" style="color:#f59e0b; font-weight:bold;">\u2502</span>';
            const gapChars = gapLabel.split('');
            for (let k = 0; k < gapChars.length; k++) html += '<span class="msaBase" style="color:#666;">' + gapChars[k] + '</span>';
            html += '<span class="msaBase" style="color:#f59e0b; font-weight:bold;">\u2502</span>';
            for (let k = 0; k < 50; k++) html += baseSpan(right50[k], '', 'spacer', 'spacer pos ' + (row.spacerLen - 50 + k + 1));
          } else {
            for (let k = 0; k < displaySpacer.length; k++) {
              html += baseSpan(displaySpacer[k], '', 'spacer', 'spacer pos ' + (k+1));
            }
          }
          html += '</div>';
        }
      }

      const clsatCol = CLSAT_COLORS[row.clsat] || '#888';
      html += '<div class="msaRow" data-monid="' + row.monId + '"><span class="msaName" title="' + row.hoverTitle + '" style="color:' + clsatCol + ';">' + row.name + '</span>';

      // Left region
      if (row.isFirst && nBefore > 0) {
        const padCount = nBefore - row.flankLeftStr.length;
        for (let k = 0; k < padCount; k++) html += '<span class="msaBase"> </span>';
        for (let k = 0; k < row.flankLeftStr.length; k++) {
          const dist = -(row.flankLeftStr.length - k);
          html += baseSpan(row.flankLeftStr[k], '', 'flank', 'flank ' + dist);
        }
        html += sepSpan;
      } else if (nBefore > 0) {
        for (let k = 0; k < nBefore; k++) html += '<span class="msaBase"> </span>';
        html += '<span class="msaBase"> </span>';
      }

      // Consensus-projected bases
      let gapFreePos = 0;
      for (let k = 0; k < consLen; k++) {
        const b = row.bases[k] || '-';
        let tip = '';
        if (b !== '-') { gapFreePos++; tip = 'pos ' + gapFreePos; }
        html += baseSpan(b, consU[k], null, tip);
      }

      // Right: remaining overhang for ANY monomer (shown after consensus cols)
      if (row.monOverRight.length > 0) {
        html += '<span class="msaBase" style="color:#f59e0b;">\u2502</span>';
        for (let k = 0; k < row.monOverRight.length; k++) {
          html += baseSpan(row.monOverRight[k], '', 'overhang', 'overhang +' + (k+1));
        }
      }

      // Right flank columns (only for isLast)
      if (row.isLast && nAfter > 0) {
        if (!row.monOverRight.length) html += sepSpan;
        for (let k = 0; k < row.flankRightStr.length; k++) {
          html += baseSpan(row.flankRightStr[k], '', 'flank', 'flank +' + (k+1));
        }
        const padCount = nAfter - row.flankRightStr.length;
        for (let k = 0; k < padCount; k++) html += '<span class="msaBase"> </span>';
      } else if (nAfter > 0 && !row.monOverRight.length) {
        html += '<span class="msaBase"> </span>';
        for (let k = 0; k < nAfter; k++) html += '<span class="msaBase"> </span>';
      }

      html += '<span class="msaIdent">' + (row.identity*100).toFixed(0) + '%</span>';
      html += '</div>';
    });

    // Conservation row removed (user preference)

    // Per-array Copy FASTA button
    html += '<div style="margin:3px 0 1px 0;"><button class="copyBtn copyFastaArrayBtn" data-array-idx="' + ai + '" style="font-size:10px; padding:3px 8px;">Copy FASTA</button></div>';

    html += '</div>';
  });

  container.innerHTML = html;

  // Store FASTA data for copy button (all arrays combined)
  const fastaBtn = document.getElementById('copyFastaAlnBtn');
  if (fastaBtn) {
    fastaBtn.style.display = 'inline-block';
    fastaBtn.textContent = 'Copy All FASTA';
    fastaBtn.onclick = () => {
      const fastaText = fastaLines.join('\n');
      navigator.clipboard.writeText(fastaText).then(() => {
        fastaBtn.textContent = 'Copied!';
        setTimeout(() => { fastaBtn.textContent = 'Copy All FASTA'; }, 1500);
      });
    };
  }

  // Wire per-array Copy FASTA buttons
  container.querySelectorAll('.copyFastaArrayBtn').forEach(btn => {
    btn.addEventListener('click', () => {
      const ai = parseInt(btn.dataset.arrayIdx);
      // Collect FASTA lines for this array only
      // fastaLines has blocks separated by empty lines: consensus, monomers..., ""
      const blocks = [];
      let cur = [];
      fastaLines.forEach(line => {
        if (line === '' && cur.length) { blocks.push(cur); cur = []; }
        else cur.push(line);
      });
      if (cur.length) blocks.push(cur);
      const arrText = (blocks[ai] || blocks[0] || []).join('\n');
      navigator.clipboard.writeText(arrText).then(() => {
        btn.textContent = 'Copied!';
        setTimeout(() => { btn.textContent = 'Copy FASTA'; }, 1500);
      });
    });
  });

  // Wire up cross-highlighting from MSA rows → arrow map
  container.querySelectorAll('.msaRow[data-monid]').forEach(row => {
    row.addEventListener('mouseenter', () => highlightMonomer(row.dataset.monid, true));
    row.addEventListener('mouseleave', () => highlightMonomer(null, false));
  });
}

/** Cross-highlight a monomer in both the arrow map and the MSA (debounced) */
let _hlTimer = null;
function highlightMonomer(monId, on) {
  if (_hlTimer) { clearTimeout(_hlTimer); _hlTimer = null; }
  if (!on) {
    _hlTimer = setTimeout(() => {
      document.querySelectorAll('.monomerMap-arrow.hl,.monomerMap-arrow.dim').forEach(el => el.classList.remove('hl','dim'));
      document.querySelectorAll('.msaRow.hl,.msaRow.dim').forEach(el => el.classList.remove('hl','dim'));
    }, 200);
    return;
  }
  // Arrow map
  document.querySelectorAll('.monomerMap-arrow[data-monid]').forEach(el => {
    if (el.dataset.monid === monId) { el.classList.add('hl'); el.classList.remove('dim'); }
    else { el.classList.add('dim'); el.classList.remove('hl'); }
  });
  // MSA rows
  document.querySelectorAll('.msaRow[data-monid]').forEach(el => {
    if (el.dataset.monid === monId) { el.classList.add('hl'); el.classList.remove('dim'); }
    else { el.classList.add('dim'); el.classList.remove('hl'); }
  });
}

/**
 * Draw monomer strand overlay on the detail chart.
 * Shows colored markers below the bars to indicate strand direction.
 */
function renderStrandTrack() {
  if (!currentLocus || !currentLocus._monomerResult || !svgDetail) return;
  const result = currentLocus._monomerResult;
  if (!result.success || !result.arrays.length) return;

  const {innerW, innerH, margin} = getDetailSize();
  const trackH = 14;
  const trackY = innerH - trackH - 2;

  // Remove previous strand track
  gMainDetail.selectAll('.strandTrack').remove();
  const gStrand = gMainDetail.append('g').attr('class', 'strandTrack');

  const plusColor = '#34d399', minusColor = '#f472b6';
  const locusStart = currentLocus.start;

  result.arrays.forEach(arr => {
    arr.hits.forEach(m => {
      const clsatColor = CLSAT_COLORS[m.clsat] || (arr.strand === '+' ? plusColor : minusColor);
      const gStart = m.start + locusStart;
      const gEnd = m.end + locusStart;
      const x1 = xScaleDetail(gStart);
      const x2 = xScaleDetail(gEnd);
      const w = Math.max(x2 - x1, 2);
      if (x2 < 0 || x1 > innerW) return; // off-screen

      gStrand.append('rect')
        .attr('x', x1).attr('y', trackY)
        .attr('width', w).attr('height', trackH)
        .attr('fill', clsatColor).attr('opacity', 0.6)
        .attr('rx', 2);

      // Arrow indicator if wide enough
      if (w > 8) {
        const arrowX = arr.strand === '+' ? x1 + w - 4 : x1 + 2;
        const arrowChar = arr.strand === '+' ? '\u25B6' : '\u25C0';
        gStrand.append('text')
          .attr('x', arrowX).attr('y', trackY + trackH - 3)
          .attr('fill', '#fff').attr('font-size', '8px')
          .attr('pointer-events', 'none')
          .text(arrowChar);
      }
    });
  });

  // Legend
  gStrand.append('text')
    .attr('x', -4).attr('y', trackY + trackH - 3)
    .attr('text-anchor', 'end').attr('fill', '#9ca3af')
    .attr('font-size', '8px').attr('font-family', 'ui-monospace, monospace')
    .text('strand');
}

function getBaseUrl() {
  const loc = window.location.href;
  return loc.substring(0, loc.lastIndexOf('/') + 1);
}
const BASE_URL = getBaseUrl();

/* ============================================================================
   STATE
============================================================================ */
let loci = [];            // {id, sp, scf, start, end, name}
let assignments = {};     // id -> {seed, seedBits, best, bestBits, delta, flag}
let bits = {};            // id -> {b1,b2,b3,b4}

// Per-window data: indexed by scaffold -> sorted array of {pos, bits, name, clsat}
let perWindowByScaffold = new Map();

let speciesList = [];
let scaffoldBySpecies = new Map();
let lociBySpScf = new Map();
let jumpItems = [];

// Overview chart state
let svgOver, gMainOver, gAxisOver, gLociOver, gBarsOver, zoomOver;
let xScaleOver, xAxisOver, xScaleOverBase;
let baseDomainOver = [0,1];
let currentOver = null;
let overviewWindows = [];  // per-window data for current scaffold
let overviewMaxBits = 1;

// Detail chart state
let svgDetail, gMainDetail, gAxisDetail, gBarsDetail, zoomDetail;
let xScaleDetail, xAxisDetail, xScaleDetailBase;
let baseDomainDetail = [0,1];
let currentLocus = null;

const CLSAT_COLORS = {
  CLsat1: "#60a5fa",  // blue (solid)
  CLsat2: "#34d399",  // green (solid)
  CLsat3: "#f472b6",  // pink (solid)
  CLsat4: "#fbbf24",  // yellow (solid)
};

const fmt = d => typeof d === "number" ? d.toFixed(1) : d;
const key = (sp, scf) => `${sp}\t${scf}`;

/* ============================================================================
   DOM refs
============================================================================ */
const statusEl = document.getElementById("status");
const fileOk = document.getElementById("fileOk");
const speciesSel = document.getElementById("speciesSel");
const scaffoldSel = document.getElementById("scaffoldSel");
const jumpSel = document.getElementById("jumpSel");
const flagFilter = document.getElementById("flagFilter");
const kpiLoci = document.getElementById("kpiLoci");
const kpiVis = document.getElementById("kpiVis");
const kpiWindows = document.getElementById("kpiWindows");
const kpiMaxBits = document.getElementById("kpiMaxBits");
const detailTitle = document.getElementById("detailTitle");
const bedCoord = document.getElementById("bedCoord");

function setStatus(msg){ statusEl.textContent = msg; }
function hasD3(){ return typeof d3 !== "undefined"; }

/* ============================================================================
   PARSERS
============================================================================ */
function parseMasterMerged(text){
  const arr = [];
  const lines = text.split("\n");
  let lineNum = 0;
  for (const line of lines){
    const p = line.trim().split("\t");
    if (p.length < 4) continue;
    lineNum++;
    const scf = p[0];
    const start = +p[1];
    const end = +p[2];
    const name = p[3];
    // species is first part before |
    const sp = name.split("|")[0];
    // ID is the locus ID stored in the 3rd pipe-delimited field of the BED name
    const id = name.split("|")[2] || ("L" + lineNum);
    arr.push({id, sp, scf, start, end, name});
  }
  return arr;
}

function parseAssignments(text){
  const obj = {};
  const lines = text.trim().split("\n");
  if (!lines.length) return obj;
  // Check header
  let startIdx = 0;
  if (lines[0].toLowerCase().includes("locus_id") || lines[0].toLowerCase().includes("locus\t")) startIdx = 1;
  for (let i = startIdx; i < lines.length; i++){
    const line = lines[i];
    const p = line.split("\t");
    if (p.length < 7) continue;
    const id = p[0];
    obj[id] = {
      seed: p[1],
      seedBits: +p[2],
      best: p[3],
      bestBits: +p[4],
      delta: +p[5],
      flag: p[6]
    };
  }
  return obj;
}

function parseBitsMatrix(text){
  const obj = {};
  const lines = text.trim().split("\n");
  for (const line of lines){
    const p = line.split("\t");
    if (p.length < 5) continue;
    if (p[0].toLowerCase() === "locus_id" || p[0].toLowerCase() === "locus") continue;
    obj[p[0]] = { b1: +p[1], b2: +p[2], b3: +p[3], b4: +p[4] };
  }
  return obj;
}

// Per-window bits file format: scaffold\tpos\tbits\tname\tspecies
function parsePerWindowBits(text, clsat){
  const rows = [];
  const lines = text.trim().split("\n");
  let startIdx = 0;
  if (lines[0] && lines[0].toLowerCase().startsWith("scaffold")) startIdx = 1;
  for (let i = startIdx; i < lines.length; i++){
    const p = lines[i].split("\t");
    if (p.length < 3) continue;
    const scf = p[0];
    const pos = +p[1];
    const b = +p[2];
    rows.push({scf, pos, bits: b, clsat});
  }
  return rows;
}

/* ============================================================================
   INDEXES
============================================================================ */
function buildIndexes(){
  const spSet = new Set();
  scaffoldBySpecies.clear();
  lociBySpScf.clear();

  for (const l of loci){
    spSet.add(l.sp);
    if (!scaffoldBySpecies.has(l.sp)) scaffoldBySpecies.set(l.sp, new Set());
    scaffoldBySpecies.get(l.sp).add(l.scf);
    const k = key(l.sp, l.scf);
    if (!lociBySpScf.has(k)) lociBySpScf.set(k, []);
    lociBySpScf.get(k).push(l);
  }

  speciesList = [...spSet].sort();
  for (const [sp, set] of scaffoldBySpecies) scaffoldBySpecies.set(sp, [...set].sort());
  for (const [k, arr] of lociBySpScf) arr.sort((a,b) => a.start - b.start);

  // Build jump list: contradictions + competitors
  jumpItems = [];
  const contra = loci.filter(l => assignments[l.id]?.flag === "SEED_CONTRADICTION")
    .map(l => ({label: `⚠ ${l.id} (${l.scf.slice(-6)})`, sp: l.sp, scf: l.scf, id: l.id, start: l.start}));
  contra.sort((a,b) => a.id.localeCompare(b.id));
  jumpItems.push(...contra.slice(0, 100));
  
  const comp = loci.filter(l => assignments[l.id]?.flag === "SEED_WITH_COMPETITOR")
    .map(l => ({label: `● ${l.id} (${l.scf.slice(-6)})`, sp: l.sp, scf: l.scf, id: l.id, start: l.start}));
  comp.sort((a,b) => a.id.localeCompare(b.id));
  jumpItems.push(...comp.slice(0, 100));
}

function buildPerWindowIndex(rows){
  for (const r of rows){
    if (!perWindowByScaffold.has(r.scf)){
      perWindowByScaffold.set(r.scf, []);
    }
    perWindowByScaffold.get(r.scf).push(r);
  }
}

function sortPerWindowIndex(){
  for (const [scf, arr] of perWindowByScaffold){
    arr.sort((a,b) => a.pos - b.pos);
  }
}

/* ============================================================================
   SELECTORS
============================================================================ */
function populateSelectors(){
  speciesSel.innerHTML = "";
  for (const sp of speciesList){
    const opt = document.createElement("option");
    opt.value = sp;
    opt.textContent = sp;
    speciesSel.appendChild(opt);
  }
  speciesSel.value = speciesList[0] || "";
  populateScaffolds(speciesList[0]);

  jumpSel.innerHTML = "<option value=''>—</option>";
  for (const j of jumpItems){
    const opt = document.createElement("option");
    opt.value = j.id;
    opt.textContent = j.label;
    jumpSel.appendChild(opt);
  }
}

function populateScaffolds(sp){
  scaffoldSel.innerHTML = "";
  const scaffolds = scaffoldBySpecies.get(sp) || [];
  for (const scf of scaffolds){
    const opt = document.createElement("option");
    opt.value = scf;
    opt.textContent = scf;
    scaffoldSel.appendChild(opt);
  }
  scaffoldSel.value = scaffolds[0] || "";
}

/* ============================================================================
   FILTERS
============================================================================ */
function passesFilter(l){
  const val = flagFilter.value;
  if (val === "ALL") return true;
  const a = assignments[l.id];
  if (!a) return val === "ALL";
  return a.flag === val;
}

/* ============================================================================
   OVERVIEW CHART
============================================================================ */
function getOverviewSize(){
  const box = document.getElementById("chartOverview").getBoundingClientRect();
  const margin = {top:18, right:20, bottom:22, left:50};
  const w = Math.max(600, Math.floor(box.width));
  const h = Math.max(100, Math.floor(box.height));
  return { w, h, margin, innerW: w - margin.left - margin.right, innerH: h - margin.top - margin.bottom };
}

function initOverviewChart(){
  const {w,h,margin,innerW,innerH} = getOverviewSize();
  d3.select("#chartOverview").selectAll("*").remove();

  svgOver = d3.select("#chartOverview").append("svg").attr("width", w).attr("height", h);
  gMainOver = svgOver.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
  gMainOver.append("rect").attr("x",0).attr("y",0).attr("width",innerW).attr("height",innerH).attr("fill","#070b12");
  gBarsOver = gMainOver.append("g").attr("class","bars");  // bars layer
  gLociOver = gMainOver.append("g").attr("class","loci");  // locus outlines on top
  gAxisOver = svgOver.append("g").attr("transform", `translate(${margin.left},${margin.top + innerH})`);

  xScaleOver = d3.scaleLinear().range([0, innerW]);
  xAxisOver = d3.axisBottom(xScaleOver).ticks(6).tickSizeOuter(0);

  zoomOver = d3.zoom()
    .scaleExtent([1, 80])
    .translateExtent([[0,0],[innerW,innerH]])
    .extent([[0,0],[innerW,innerH]])
    .on("zoom", (event)=>{
      const zx = event.transform.rescaleX(xScaleOverBase);
      xScaleOver.domain(zx.domain());
      renderOverview();
    });

  svgOver.call(zoomOver).on("dblclick.zoom", null);
}

function drawOverview(){
  initOverviewChart();

  const sp = speciesSel.value;
  const scf = scaffoldSel.value;
  if (!sp || !scf){ setStatus("Select species and scaffold"); return; }

  const all = lociBySpScf.get(key(sp, scf)) || [];
  const arr = all.filter(passesFilter);

  kpiLoci.textContent = all.length;
  kpiVis.textContent = arr.length;

  // Get per-window data for this scaffold
  const scfData = perWindowByScaffold.get(scf) || [];
  
  // Group by uniform display bins — snap all CLsat positions to a common grid
  // so bars from different CLsats at the same genomic region are grouped together
  const byBin = new Map();
  for (const r of scfData){
    const binPos = Math.round(r.pos / WINDOW_STEP) * WINDOW_STEP;
    if (!byBin.has(binPos)){
      byBin.set(binPos, {pos: binPos, CLsat1: 0, CLsat2: 0, CLsat3: 0, CLsat4: 0});
    }
    const bin = byBin.get(binPos);
    if (r.bits > bin[r.clsat]) bin[r.clsat] = r.bits;
  }
  overviewWindows = [...byBin.values()].sort((a,b) => a.pos - b.pos);
  overviewMaxBits = Math.max(1, ...overviewWindows.flatMap(w => [w.CLsat1, w.CLsat2, w.CLsat3, w.CLsat4]));

  if (!overviewWindows.length && !arr.length){
    setStatus(`No data for ${sp} / ${scf}`);
    return;
  }

  // Domain from windows or loci
  let min, max;
  if (overviewWindows.length){
    min = overviewWindows[0].pos;
    max = overviewWindows[overviewWindows.length - 1].pos;
  } else {
    min = d3.min(arr, d=>d.start);
    max = d3.max(arr, d=>d.end);
  }
  const span = max - min;
  const pad = Math.max(1000, span * 0.05);
  min = Math.max(0, min - pad);
  max = max + pad;

  baseDomainOver = [min, max];
  xScaleOverBase = d3.scaleLinear().domain(baseDomainOver).range(xScaleOver.range());
  xScaleOver.domain(baseDomainOver);
  gAxisOver.call(xAxisOver);

  currentOver = {sp, scf, loci: arr};
  renderOverview();
}

function fillColorForLocus(l){
  const a = assignments[l.id];
  if (!a) return "#64748b";  // solid slate color for no assignment
  if (a.flag === "SEED_CONTRADICTION") return "#ef4444";
  if (a.flag === "SEED_WITH_COMPETITOR") return "#f59e0b";
  if (a.flag === "SEED_CONFLICT") return "#a855f7";
  return "#22c55e";
}

function strokeForLocus(l){
  const a = assignments[l.id];
  if (!a) return "#475569";
  if (a.flag === "SEED_CONTRADICTION") return "var(--strokeContra)";
  if (a.flag === "SEED_WITH_COMPETITOR") return "var(--strokeComp)";
  return "var(--strokeOk)";
}

function renderOverview(){
  if (!currentOver) return;
  const arr = currentOver.loci;
  const {innerH, innerW} = getOverviewSize();

  gAxisOver.call(xAxisOver.scale(xScaleOver));

  const [xmin, xmax] = xScaleOver.domain();

  // Y scale for bars
  const yScale = d3.scaleLinear().domain([0, overviewMaxBits]).range([innerH, 0]);

  // Filter windows to visible range
  const visWindows = overviewWindows.filter(w => w.pos >= xmin && w.pos <= xmax);

  // Bar width: adjacent, no gaps
  let barW = 1;
  if (visWindows.length > 1){
    const pxMin = xScaleOver(visWindows[0].pos);
    const pxMax = xScaleOver(visWindows[visWindows.length - 1].pos);
    barW = Math.max(1, (pxMax - pxMin) / (visWindows.length - 1));
  }

  // Build bar data (4 bars per window, sorted by bits descending so tallest drawn first = in back)
  const CLSATS = ["CLsat1", "CLsat2", "CLsat3", "CLsat4"];
  const barData = [];
  for (const w of visWindows){
    const items = CLSATS.map(c => ({pos: w.pos, clsat: c, bits: w[c]}));
    items.sort((a,b) => b.bits - a.bits);  // tallest first (drawn first = behind)
    barData.push(...items);
  }

  const bars = gBarsOver.selectAll("rect.bar").data(barData, (d,i) => `${d.pos}:${d.clsat}`);
  bars.exit().remove();
  const bEnt = bars.enter().append("rect").attr("class", "bar").style("pointer-events", "none");
  bEnt.append("title");
  const allBars = bEnt.merge(bars);
  allBars
    .attr("x", d => xScaleOver(d.pos) - barW/2)
    .attr("width", barW)
    .attr("y", d => yScale(d.bits))
    .attr("height", d => Math.max(0, innerH - yScale(d.bits)))
    .attr("fill", d => CLSAT_COLORS[d.clsat] || "#888");
  allBars.select("title").text(d => `${d.clsat} pos=${d.pos} bits=${fmt(d.bits)}`);

  // Locus outlines (clickable rectangles with no fill, just stroke)
  const visLoci = arr.filter(d => d.end >= xmin && d.start <= xmax);
  const rectH = innerH;
  const rectY = 0;

  const sel = gLociOver.selectAll("rect.locus").data(visLoci, d=>d.id);
  sel.exit().remove();
  const ent = sel.enter().append("rect")
    .attr("class", "locus")
    .attr("y", rectY)
    .attr("height", rectH)
    .style("cursor", "pointer")
    .on("click", (event, d) => selectLocus(d));
  ent.append("title");

  const allRects = ent.merge(sel);
  allRects
    .attr("x", d => xScaleOver(d.start))
    .attr("width", d => Math.max(4, xScaleOver(d.end) - xScaleOver(d.start)))
    .attr("fill", "rgba(255,255,255,0.01)")  // nearly transparent but clickable
    .attr("stroke", d => currentLocus?.id === d.id ? "#fff" : "rgba(255,255,255,0.4)")
    .attr("stroke-width", d => currentLocus?.id === d.id ? 2 : 1);
  allRects.select("title").text(d => `${d.id}\n${d.scf}:${d.start}-${d.end}\nClick to view per-window bits`);

  // Labels for loci (only if zoomed in enough)
  const labels = gLociOver.selectAll("text.locusLabel").data(visLoci, d=>d.id);
  labels.exit().remove();
  const labEnt = labels.enter().append("text")
    .attr("class", "locusLabel")
    .attr("fill", "#fff")
    .attr("font-size", "9px")
    .attr("font-weight", "500")
    .attr("pointer-events", "none")
    .attr("text-anchor", "middle")
    .attr("dy", "-4");
  const allLabels = labEnt.merge(labels);
  allLabels
    .attr("x", d => xScaleOver((d.start + d.end) / 2))
    .attr("y", rectY)
    .text(d => {
      // Only show label if locus is wide enough
      const w = xScaleOver(d.end) - xScaleOver(d.start);
      return w > 25 ? d.id : "";
    });
}

/* ============================================================================
   DETAIL CHART (per-window bitscores)
============================================================================ */
function getDetailSize(){
  const box = document.getElementById("chartDetail").getBoundingClientRect();
  const margin = {top:20, right:20, bottom:30, left:60};
  const w = Math.max(600, Math.floor(box.width));
  const h = Math.max(200, Math.floor(box.height));
  return { w, h, margin, innerW: w - margin.left - margin.right, innerH: h - margin.top - margin.bottom };
}

function initDetailChart(){
  const {w,h,margin,innerW,innerH} = getDetailSize();
  d3.select("#chartDetail").selectAll("*").remove();

  svgDetail = d3.select("#chartDetail").append("svg").attr("width", w).attr("height", h);
  gMainDetail = svgDetail.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
  gMainDetail.append("rect").attr("x",0).attr("y",0).attr("width",innerW).attr("height",innerH).attr("fill","#070b12");
  gBarsDetail = gMainDetail.append("g").attr("class","bars");
  gAxisDetail = svgDetail.append("g").attr("transform", `translate(${margin.left},${margin.top + innerH})`);

  // Y axis group
  gMainDetail.append("g").attr("class","yaxis");

  xScaleDetail = d3.scaleLinear().range([0, innerW]);
  xAxisDetail = d3.axisBottom(xScaleDetail).ticks(8).tickSizeOuter(0);

  zoomDetail = d3.zoom()
    .scaleExtent([1, 50])
    .translateExtent([[0,0],[innerW,innerH]])
    .extent([[0,0],[innerW,innerH]])
    .on("zoom", (event)=>{
      const zx = event.transform.rescaleX(xScaleDetailBase);
      xScaleDetail.domain(zx.domain());
      renderDetail();
    });

  svgDetail.call(zoomDetail).on("dblclick.zoom", null);
}

function selectLocus(l){
  currentLocus = l;
  detailTitle.textContent = `${l.id} (${l.scf}:${l.start}-${l.end})`;
  detailTitle.style.color = "#60a5fa";

  const a = assignments[l.id];
  const b = bits[l.id] || {};
  let s = `Selected: ${l.id}\n${l.scf}:${l.start}-${l.end}\n`;
  if (a) s += `Seed: ${a.seed} (${fmt(a.seedBits)}), Best other: ${a.best} (${fmt(a.bestBits)}), Δ=${fmt(a.delta)}, Flag=${a.flag}\n`;
  s += `Max bits: CLsat1=${fmt(b.b1||0)} CLsat2=${fmt(b.b2||0)} CLsat3=${fmt(b.b3||0)} CLsat4=${fmt(b.b4||0)}`;
  setStatus(s);

  // Highlight in overview
  renderOverview();

  // Draw detail
  drawDetailForLocus(l);
}

// Per-CLsat monomer lengths (= scan window step for each consensus)
const CLSAT_STEP = {
  CLsat1: 145,   // consensus 146 bp, scan step 145
  CLsat2: 145,   // consensus 145 bp, scan step 145
  CLsat3: 146,   // consensus 146 bp, scan step 146
  CLsat4: 116,   // consensus 116 bp, scan step 116
};
const WINDOW_STEP = 146;  // uniform display grid for grouping bars from different CLsats

function drawDetailForLocus(l){
  initDetailChart();

  const scfData = perWindowByScaffold.get(l.scf) || [];
  // Filter to locus region
  const data = scfData.filter(r => r.pos >= l.start && r.pos <= l.end);

  if (!data.length){
    kpiWindows.textContent = "0";
    kpiMaxBits.textContent = "0";
    detailTitle.textContent += " (no per-window data)";
    setStatus(statusEl.textContent + "\nNo per-window data found for this locus.");
    return;
  }

  // Group by uniform display bins — snap to common grid so CLsat bars align
  const byBin = new Map();
  for (const r of data){
    const binPos = Math.round(r.pos / WINDOW_STEP) * WINDOW_STEP;
    if (!byBin.has(binPos)){
      byBin.set(binPos, {pos: binPos, CLsat1: 0, CLsat2: 0, CLsat3: 0, CLsat4: 0});
    }
    const bin = byBin.get(binPos);
    if (r.bits > bin[r.clsat]) bin[r.clsat] = r.bits;
  }

  // Convert to array of windows sorted by position
  const windows = [...byBin.values()].sort((a,b) => a.pos - b.pos);
  kpiWindows.textContent = windows.length;

  const maxBits = Math.max(...windows.flatMap(w => [w.CLsat1, w.CLsat2, w.CLsat3, w.CLsat4])) || 1;
  kpiMaxBits.textContent = fmt(maxBits);

  // Domain
  const minPos = windows[0].pos;
  const maxPos = windows[windows.length - 1].pos;
  const span = maxPos - minPos;
  const pad = Math.max(200, span * 0.02);

  baseDomainDetail = [minPos - pad, maxPos + pad];
  xScaleDetailBase = d3.scaleLinear().domain(baseDomainDetail).range(xScaleDetail.range());
  xScaleDetail.domain(baseDomainDetail);

  currentLocus._windows = windows;
  currentLocus._maxBits = maxBits;

  renderDetail();
}

function renderDetail(){
  if (!currentLocus || !currentLocus._windows) return;
  const windows = currentLocus._windows;
  const maxBits = currentLocus._maxBits;
  const {innerW, innerH} = getDetailSize();

  gAxisDetail.call(xAxisDetail.scale(xScaleDetail));

  // Y scale
  const yScale = d3.scaleLinear().domain([0, maxBits]).range([innerH, 0]);
  const yAxis = d3.axisLeft(yScale).ticks(5);
  gMainDetail.select("g.yaxis").call(yAxis);

  const [xmin, xmax] = xScaleDetail.domain();
  const vis = windows.filter(w => w.pos >= xmin && w.pos <= xmax);

  // Bar width: one bar per window, adjacent with no gaps
  let barW = 4;
  if (vis.length > 1){
    const pxMin = xScaleDetail(vis[0].pos);
    const pxMax = xScaleDetail(vis[vis.length - 1].pos);
    barW = Math.max(2, (pxMax - pxMin) / (vis.length - 1));
  } else if (vis.length === 1){
    barW = 20;
  }

  // Build bar data: 4 bars per window, sorted by bits descending so tallest drawn first (in back)
  const CLSATS = ["CLsat1", "CLsat2", "CLsat3", "CLsat4"];
  const barData = [];
  for (const w of vis){
    // Get all 4 CLsat values and sort by bits descending (tallest first = drawn first = behind)
    const items = CLSATS.map(c => ({pos: w.pos, clsat: c, bits: w[c]}));
    items.sort((a,b) => b.bits - a.bits);
    barData.push(...items);
  }

  const bars = gBarsDetail.selectAll("rect.bar").data(barData, (d,i) => `${d.pos}:${d.clsat}`);
  bars.exit().remove();
  const ent = bars.enter().append("rect")
    .attr("class", "bar");
  ent.append("title");

  const all = ent.merge(bars);
  all
    .attr("x", d => xScaleDetail(d.pos) - barW/2)
    .attr("width", barW)
    .attr("y", d => yScale(d.bits))
    .attr("height", d => Math.max(0, innerH - yScale(d.bits)))
    .attr("fill", d => CLSAT_COLORS[d.clsat] || "#888");
  all.select("title").text(d => `${d.clsat} pos=${d.pos} bits=${fmt(d.bits)}`);

  // Update BED coordinates display
  const start = Math.floor(xmin);
  const end = Math.ceil(xmax);
  bedCoord.textContent = `${currentLocus.scf}\t${start}\t${end}`;

  // Render strand track if monomer analysis was done for this locus
  renderStrandTrack();
}

/* ============================================================================
   LOADERS
============================================================================ */
async function fetchText(path){
  const url = BASE_URL + path;
  const r = await fetch(url, {cache:"no-store"});
  if (!r.ok) throw new Error(`Cannot load ${url} (HTTP ${r.status})`);
  return await r.text();
}

async function loadViaFetch(){
  setStatus("Loading files via fetch()…");

  // Load main files
  const [mText, aText, bText] = await Promise.all([
    fetchText(FILE_MASTER_MERGED),
    fetchText(FILE_ASSIGN),
    fetchText(FILE_BITS_MATRIX),
  ]);

  loci = parseMasterMerged(mText);
  assignments = parseAssignments(aText);
  bits = parseBitsMatrix(bText);

  buildIndexes();
  populateSelectors();

  setStatus(`Loaded ${loci.length} loci. Now loading per-window bits files…`);

  // Load per-window bits files
  const perWindowPromises = Object.entries(FILE_BITS_CLSAT).map(async ([clsat, file]) => {
    try {
      const text = await fetchText(file);
      const rows = parsePerWindowBits(text, clsat);
      buildPerWindowIndex(rows);
      return {clsat, count: rows.length};
    } catch (e) {
      console.warn(`Could not load ${file}: ${e.message}`);
      return {clsat, count: 0, error: e.message};
    }
  });

  const results = await Promise.all(perWindowPromises);
  sortPerWindowIndex();

  let totalRows = 0;
  let details = [];
  for (const r of results){
    if (r.count > 0){
      totalRows += r.count;
      details.push(`${r.clsat}: ${r.count.toLocaleString()}`);
    } else if (r.error){
      details.push(`${r.clsat}: failed`);
    }
  }

  fileOk.textContent = "loaded ✓";
  fileOk.className = "pill ok";

  setStatus(
    `Loaded ${loci.length} loci, ${Object.keys(assignments).length} assignments\n` +
    `Per-window data: ${totalRows.toLocaleString()} rows\n` +
    details.join(", ") + "\n\n" +
    `Select a scaffold then click a locus to see per-window bitscores.`
  );

  if (hasD3()) drawOverview();
}

/* ============================================================================
   UI BINDING
============================================================================ */
let uiBound = false;
function bindUIOnce(){
  if (uiBound) return;
  uiBound = true;

  speciesSel.addEventListener("change", ()=>{
    populateScaffolds(speciesSel.value);
    drawOverview();
  });
  scaffoldSel.addEventListener("change", drawOverview);
  flagFilter.addEventListener("change", drawOverview);

  document.getElementById("findBtn").addEventListener("click", ()=>{
    const q = document.getElementById("findInput").value.trim();
    if (!q) return;
    jumpToLocusId(q);
  });

  // Collapse sidebar toggle
  document.getElementById('collapseBtn').addEventListener('click', () => {
    const wrap = document.querySelector('.wrap');
    wrap.classList.toggle('collapsed');
    document.getElementById('collapseBtn').textContent = wrap.classList.contains('collapsed') ? '\u00bb' : '\u00ab';
    setTimeout(() => { drawOverview(); if (currentLocus) drawDetail(); }, 250);
  });

  document.getElementById("resetBtn").addEventListener("click", ()=>{
    if (svgOver && zoomOver) d3.select(svgOver.node()).transition().duration(200).call(zoomOver.transform, d3.zoomIdentity);
    if (svgDetail && zoomDetail) d3.select(svgDetail.node()).transition().duration(200).call(zoomDetail.transform, d3.zoomIdentity);
  });

  jumpSel.addEventListener("change", ()=>{
    const id = jumpSel.value;
    if (id) jumpToLocusId(id);
  });

  // Monomer analysis is now fully client-side (Smith-Waterman in JS).
  // Server status UI elements are hidden.
  const swStatusEl = document.getElementById("serverStatus");
  if (swStatusEl) { swStatusEl.textContent = "✓ Client-side SW"; swStatusEl.style.color = "#34d399"; }
  const serverToggleBtn = document.getElementById("serverToggleBtn");
  if (serverToggleBtn) serverToggleBtn.style.display = "none";

  const CONTROL_BASE = "http://127.0.0.1:9001"; // kept for reference only

  // Server polling disabled — monomer analysis is now client-side

  document.getElementById("copyBedBtn").addEventListener("click", ()=>{
    const text = bedCoord.textContent;
    if (!text || text.includes("will appear")) return;
    console.log("[BED Copy] Copying:", text);
    navigator.clipboard.writeText(text).then(()=>{
      const btn = document.getElementById("copyBedBtn");
      const orig = btn.textContent;
      btn.textContent = "Copied!";
      console.log("[BED Copy] ✓ Successfully copied to clipboard");
      setStatus(`BED coordinates copied:\n${text}\n\nReady for: bedtools getfasta -fi genome.fa -bed coords.bed`);
      setTimeout(()=> btn.textContent = orig, 1500);
    }).catch(e => {
      console.error("[BED Copy] ✗ Failed:", e);
      alert("Copy failed. Please select and copy manually: " + text);
    });
  });

  document.getElementById("fastaBtn").addEventListener("click", async ()=>{
    if (!currentLocus) {
      console.warn("[FASTA] No locus selected");
      return;
    }
    const btn = document.getElementById("fastaBtn");
    const resultBox = document.getElementById("fastaResult");
    const statusEl = document.getElementById("fastaStatus");
    const seqEl = document.getElementById("fastaSeq");
    const copyBtn = document.getElementById("copyFastaBtn");
    
    // Get current coordinates from detail view
    const [start, end] = xScaleDetail.domain().map(Math.round);
    const scf = currentLocus.scf;
    const length = end - start + 1;
    
    console.log("[FASTA] === FETCH START ===");
    console.log("[FASTA] Locus:", currentLocus);
    console.log("[FASTA] Scaffold:", scf);
    console.log("[FASTA] Coordinates:", start, "-", end, "(length:", length, "bp)");
    
    // Warning for large sequences
    if (length > 15000) {
      const proceed = confirm(
        `Warning: This will fetch ${length.toLocaleString()} nucleotides from NCBI.\n\n` +
        `Large sequences may take time to download and display.\n\n` +
        `Continue?`
      );
      if (!proceed) {
        console.log("[FASTA] User cancelled large fetch");
        return;
      }
      console.log("[FASTA] User confirmed large fetch");
    }
    
    // Show loading
    btn.disabled = true;
    btn.textContent = "Fetching...";
    resultBox.classList.add("show");
    statusEl.textContent = "Fetching from NCBI...";
    seqEl.textContent = "";
    copyBtn.style.display = "none";
    
    try {
      const fasta = await fetchNCBIFasta(scf, start, end);
      console.log("[FASTA] ✓ Success! Received", fasta.length, "characters");
      console.log("[FASTA] First 200 chars:", fasta.substring(0, 200));
      statusEl.textContent = `${scf}:${start}-${end} (${end - start + 1} bp)`;
      seqEl.textContent = fasta;
      copyBtn.style.display = "inline-block";
      setStatus(`FASTA sequence fetched from NCBI:\n${scf}:${start}-${end}\n${fasta.length} characters`);
      
      // Setup copy FASTA button
      copyBtn.onclick = ()=>{
        navigator.clipboard.writeText(fasta).then(()=>{
          const orig = copyBtn.textContent;
          copyBtn.textContent = "Copied!";
          console.log("[FASTA] ✓ FASTA copied to clipboard");
          setTimeout(()=> copyBtn.textContent = orig, 1500);
        }).catch(e => {
          console.error("[FASTA] ✗ Copy failed:", e);
          alert("Copy failed. Please select and copy manually.");
        });
      };
    } catch (e) {
      console.error("[FASTA] ✗ FAILED:", e);
      console.error("[FASTA] Error details:", e.message, e.stack);
      statusEl.textContent = "Error: " + e.message;
      seqEl.textContent = "Failed to fetch sequence. Make sure the scaffold name is a valid NCBI accession (e.g., NC_123456 or NW_123456).\n\nAlternatively, use the 'Copy BED' button and run:\n  bedtools getfasta -fi genome.fa -bed coords.bed";
      setStatus(`FASTA fetch failed: ${e.message}`);
    } finally {
      btn.disabled = false;
      btn.textContent = "Get FASTA";
      console.log("[FASTA] === FETCH END ===");
    }
  });

  document.getElementById("monomerBtn").addEventListener("click", async ()=>{
    if (!currentLocus) {
      console.warn("[MONOMER] No locus selected");
      return;
    }

    const btn = document.getElementById("monomerBtn");
    const resultBox = document.getElementById("monomerResult");
    const mStatusEl = document.getElementById("monomerStatus");
    const listEl = document.getElementById("monomerList");
    const alignEl = document.getElementById("alignmentBox");
    const copyBtn = document.getElementById("copyAlignmentBtn");

    // Get current coordinates and locus info
    const [start, end] = xScaleDetail.domain().map(Math.round);
    const scf = currentLocus.scf;
    const length = end - start + 1;

    // Get consensus from assignment
    const assignment = assignments[currentLocus.id];
    const consensusName = assignment?.seed || "CLsat1";

    console.log("[MONOMER] === CLIENT-SIDE SW ANALYSIS START ===");
    console.log("[MONOMER] Locus:", currentLocus.id);
    console.log("[MONOMER] Length:", length, "bp");
    console.log("[MONOMER] Consensus:", consensusName);

    // Show loading
    btn.disabled = true;
    btn.textContent = "Analyzing...";
    resultBox.classList.add("show");
    mStatusEl.textContent = "Fetching sequence from NCBI...";
    listEl.innerHTML = "";
    alignEl.textContent = "";
    copyBtn.style.display = "none";

    try {
      // Get sequence from NCBI
      let sequence;
      try {
        sequence = await fetchNCBIFasta(scf, start, end);
        console.log("[MONOMER] Got sequence from NCBI:", sequence.length, "chars");
      } catch (e) {
        console.warn("[MONOMER] NCBI fetch failed:", e.message);
        // Check if FASTA was already fetched and is displayed
        const existingFasta = document.getElementById("fastaSeq")?.textContent;
        if (existingFasta && existingFasta.startsWith(">")) {
          sequence = existingFasta;
          console.log("[MONOMER] Using previously fetched FASTA:", sequence.length, "chars");
        } else {
          throw new Error("Cannot fetch sequence from NCBI. Click 'Get FASTA' first, then try again.");
        }
      }

      mStatusEl.textContent = "Running Smith-Waterman alignment...";

      // Get user-selected identity threshold
      const minIdentity = parseFloat(document.getElementById("minIdentity").value);
      console.log("[MONOMER] Min identity:", minIdentity);

      // Run client-side Smith-Waterman analysis
      // Use setTimeout to allow UI to update before heavy computation
      const result = await new Promise(resolve => {
        setTimeout(() => {
          resolve(analyzeMonomersSW(sequence, consensusName, minIdentity));
        }, 50);
      });

      console.log("[MONOMER] Result:", result);

      if (!result.success) {
        mStatusEl.textContent = "No monomers found";
        listEl.innerHTML = '<div style="color:#fb7185; padding:8px;">' + result.message + '</div>';
        document.getElementById('monomerMap').innerHTML = '';
        document.getElementById('monomerMSA').innerHTML = '';
        setStatus("Monomer analysis: " + result.message);
        return;
      }

      // Display results
      const avgPct = (result.avg_identity * 100).toFixed(1);
      mStatusEl.textContent = result.monomer_count + " monomers in " + result.array_count + " array(s), avg " + avgPct + "% identity";

      // Build summary per array
      let html = '';
      result.arrays.forEach((arr, ai) => {
        const arrStart = arr.hits[0].start + start; // offset to genomic coordinates
        const arrEnd = arr.hits[arr.hits.length - 1].end + start;
        // Dominant cluster for this array summary
        const sumClusterCounts = {};
        arr.hits.forEach(m => { if (m.cluster) sumClusterCounts[m.cluster] = (sumClusterCounts[m.cluster]||0)+1; });
        const sumDomCluster = Object.keys(sumClusterCounts).length > 0 ? Object.entries(sumClusterCounts).sort((a,b) => b[1]-a[1])[0][0] : '';
        const sumDomClsat = (() => { const cc = {}; arr.hits.forEach(m => { const c = m.clsat || '?'; cc[c] = (cc[c]||0)+1; }); return Object.entries(cc).sort((a,b) => b[1]-a[1])[0][0]; })();
        html += '<div style="color:#a855f7; font-weight:bold; padding:4px 6px; margin-top:6px;">' +
          'Array ' + (ai + 1) + ': ' + arrStart.toLocaleString() + '-' + arrEnd.toLocaleString() +
          ' (' + arr.hits.length + ' monomers, ' + sumDomClsat + (sumDomCluster ? '/' + sumDomCluster : '') + ', strand ' + arr.strand + ')' +
          '</div>';
        arr.hits.forEach((m, mi) => {
          const arrow = arr.strand === '+' ? '\u2192' : '\u2190';
          const clsatColor = CLSAT_COLORS[m.clsat] || (arr.strand === '+' ? '#34d399' : '#f472b6');
          const gStart = m.start + start;
          const gEnd = m.end + start;
          html += '<div class="monomerItem">' +
            '<span style="color:' + clsatColor + '; font-weight:bold;">' + arrow + '</span> ' +
            '<span style="color:' + clsatColor + '; font-size:9px;">' + (m.clsat || '') + (m.cluster ? '/' + m.cluster : '') + '</span> ' +
            '#' + (mi + 1) + ': ' + gStart.toLocaleString() + '-' + gEnd.toLocaleString() +
            ' (' + m.length + ' bp, ' + (m.identity * 100).toFixed(1) + '%)' +
            '</div>';
        });
      });
      listEl.innerHTML = html;

      // Draw visual monomer direction map
      drawMonomerMap('monomerMap', result, start, end);

      // Render MSA-style alignment (pairwise to consensus, stacked)
      const rawSeq = sequence.replace(/^>.*\n/gm, '').replace(/\s/g, '').toUpperCase();
      renderMonomerMSA('monomerMSA', result, rawSeq, start, scf);

      // Store result on locus for strand track overlay on detail chart
      if (currentLocus) {
        currentLocus._monomerResult = result;
        renderStrandTrack();
      }

      // Generate a simple text summary for copy
      const summaryLines = ['# Monomer analysis: ' + consensusName + ' in ' + scf + ':' + start + '-' + end];
      summaryLines.push('# ' + result.message);
      summaryLines.push('# Average identity: ' + avgPct + '%');
      summaryLines.push('# scaffold\tstart\tend\tlength\tidentity\tstrand\tarray\tclsat');
      result.arrays.forEach((arr, ai) => {
        arr.hits.forEach(m => {
          summaryLines.push(scf + '\t' + (m.start + start) + '\t' + (m.end + start) + '\t' + m.length + '\t' + (m.identity * 100).toFixed(1) + '\t' + arr.strand + '\t' + (ai + 1) + '\t' + (m.clsat || consensusName));
        });
      });
      const summaryText = summaryLines.join('\n');
      alignEl.textContent = summaryText;
      copyBtn.style.display = "inline-block";
      copyBtn.onclick = () => {
        navigator.clipboard.writeText(summaryText).then(() => {
          const orig = copyBtn.textContent;
          copyBtn.textContent = "Copied!";
          console.log("[MONOMER] Results copied");
          setTimeout(() => copyBtn.textContent = orig, 1500);
        }).catch(ecp => {
          console.error("[MONOMER] Copy failed:", ecp);
          alert("Copy failed.");
        });
      };

      setStatus('Monomer analysis (client-side SW):\n' + result.message + '\nConsensus: ' + consensusName + ', Avg identity: ' + avgPct + '%');

    } catch (e) {
      console.error("[MONOMER] FAILED:", e);
      mStatusEl.textContent = "Error: " + e.message;
      listEl.innerHTML = '<div style="color:#fb7185; padding:8px;">' +
        'Analysis failed: ' + e.message + '<br><br>' +
        'Tip: Click \'Get FASTA\' first to fetch the sequence, then try \'Analyze Monomers\' again.' +
        '</div>';
      setStatus('Monomer analysis failed: ' + e.message);
    } finally {
      btn.disabled = false;
      btn.textContent = "Analyze Monomers";
      console.log("[MONOMER] === ANALYSIS END ===");
    }
  });
}

async function fetchNCBIFasta(accession, start, end) {
  // NCBI E-utilities API
  // Note: For production use, should use an API key and proper error handling
  const url = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=nucleotide&id=${encodeURIComponent(accession)}&rettype=fasta&retmode=text&seq_start=${start}&seq_stop=${end}`;
  
  console.log("[FASTA API] URL:", url);
  console.log("[FASTA API] Accession:", accession, "(encoded:", encodeURIComponent(accession), ")");
  console.log("[FASTA API] Range:", start, "-", end);
  console.log("[FASTA API] Making fetch request...");
  
  try {
    const response = await fetch(url);
    console.log("[FASTA API] Response status:", response.status, response.statusText);
    console.log("[FASTA API] Response headers:", Object.fromEntries(response.headers.entries()));
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const text = await response.text();
    console.log("[FASTA API] Response length:", text.length, "characters");
    console.log("[FASTA API] First 500 chars:", text.substring(0, 500));
    
    // Check if we got an error message instead of FASTA
    if (text.includes("Error") || text.includes("error") || text.length < 10) {
      console.error("[FASTA API] Response appears to be an error:", text);
      throw new Error("Invalid accession or sequence not found");
    }
    
    // Check if it looks like FASTA format
    if (!text.startsWith(">")) {
      console.warn("[FASTA API] Response doesn't start with '>'. Full response:", text);
      throw new Error("Response is not in FASTA format");
    }
    
    console.log("[FASTA API] ✓ Valid FASTA format detected");
    return text.trim();
  } catch (e) {
    console.error("[FASTA API] Exception during fetch:", e);
    throw e;
  }
}

function jumpToLocusId(id){
  const l = loci.find(x => x.id === id);
  if (!l){ setStatus(`Locus ${id} not found`); return; }
  speciesSel.value = l.sp;
  populateScaffolds(l.sp);
  scaffoldSel.value = l.scf;
  drawOverview();
  selectLocus(l);
}

/* ============================================================================
   STARTUP
============================================================================ */
(function start(){
  bindUIOnce();

  if (!hasD3()){
    fileOk.textContent = "D3 missing";
    fileOk.className = "pill err";
    setStatus("D3 failed to load. Open in browser (not VS Code Preview) or ensure internet access.");
    return;
  }

  // Monomer analysis is now fully client-side (Smith-Waterman in JS).
  // No server auto-start needed.

  loadViaFetch().catch(e=>{
    fileOk.textContent = "fetch failed";
    fileOk.className = "pill err";
    setStatus(`Fetch load failed: ${e.message}\n\nEnsure files are in the same directory.`);
  });
})();
</script>
</body>
</html>
